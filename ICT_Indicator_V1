// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © @projjalroy

//@version=6
// All the ICT macro time_frame has been added to this version of the indicator for the convenience of the user who have done the precise course from us.
indicator("All-in-One-ICT-v1 ", max_lines_count=500, max_boxes_count=500, max_labels_count=500, max_bars_back=3000, overlay=true)


// ---------------------------------------- Inputs --------------------------------------------------
var g_SETTINGS      = "Settings"
max_days            = input.int(3, "Session Drawing Limit", 1, tooltip = "Only this many drawings will be kept on the chart, for each selected drawing type (killzone boxes, pivot lines, open lines, etc.)", group = g_SETTINGS)
tf_limit            = input.timeframe("30", "Timeframe Limit", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_SETTINGS)
gmt_tz              = input.string('GMT-5', "Timezone", options = ['GMT-12','GMT-11','GMT-10','GMT-9','GMT-8','GMT-7','GMT-6','GMT-5','GMT-4','GMT-3','GMT-2','GMT-1','GMT+0','GMT+1','GMT+2','GMT+3','GMT+4','GMT+5','GMT+6','GMT+7','GMT+8','GMT+9','GMT+10','GMT+11','GMT+12','GMT+13','GMT+14'], tooltip = "Note GMT is not adjusted to reflect Daylight Saving Time changes", group = g_SETTINGS)
lb_size             = input.string('Normal', "Label Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group = g_SETTINGS)
lb_color            = input.color(color.black, "Label Text Color", group = g_SETTINGS)
use_cutoff          = input.bool(true, "Drawing Cutoff Time", inline = "CO", tooltip = "When enabled, all highs and lows will stop extending after this time", group = g_SETTINGS)
cutoff              = input.session("1200-1201", "", inline = "CO", group = g_SETTINGS)


var g_KZ            = "Killzones"
show_kz             = input.bool(true, "Show Killzone Boxes", inline = "KZ", group = g_KZ)
show_kz_text        = input.bool(true, "Display Text", inline = "KZ", group = g_KZ)
box_transparency    = input.int(70, "Box Transparency", 0, 100, group = g_KZ)
text_transparency   = input.int(50, "Text Transparency", 0, 100, group = g_KZ)

use_asia            = input.bool(true, "", inline = "ASIA", group = g_KZ)
asia_text           = input.string("Asia", "", inline = "ASIA", group = g_KZ)
asia                = input.session("2000-0000", "", inline = "ASIA", group = g_KZ)
as_color            = input.color(color.blue, "", inline = "ASIA", group = g_KZ)

use_london          = input.bool(true, "", inline = "LONDON", group = g_KZ)
london_text         = input.string("London", "", inline = "LONDON", group = g_KZ)
london              = input.session("0200-0500", "", inline = "LONDON", group = g_KZ)
lo_color            = input.color(color.red, "", inline = "LONDON", group = g_KZ)

use_nyam            = input.bool(true, "", inline = "NYAM", group = g_KZ)
nyam_text           = input.string("NY AM", "", inline = "NYAM", group = g_KZ)
nyam                = input.session("0700-1000", "", inline = "NYAM", group = g_KZ)
na_color            = input.color(#089981, "", inline = "NYAM", group = g_KZ)

use_nylu            = input.bool(true, "", inline = "NYLU", group = g_KZ)
nylu_text           = input.string("London Close", "", inline = "NYLU", group = g_KZ)
nylu                = input.session("1100-1200", "", inline = "NYLU", group = g_KZ)
nl_color            = input.color(color.yellow, "", inline = "NYLU", group = g_KZ)

use_nypm            = input.bool(true, "", inline = "NYPM", group = g_KZ)
nypm_text           = input.string("NY PM", "", inline = "NYPM", group = g_KZ)
nypm                = input.session("1330-1600", "", inline = "NYPM", group = g_KZ)
np_color            = input.color(color.purple, "", inline = "NYPM", group = g_KZ)


var g_LABELS        = "Killzone Pivots"
show_pivots         = input.bool(true, "Show Pivots", inline = "PV", group = g_LABELS)
show_labels         = input.bool(true, "Show Labels", inline = "PV", group = g_LABELS)

ash_str             = input.string("AS.H", "Session 1 Labels", inline = "L_AS", group = g_LABELS)
asl_str             = input.string("AS.L", "", inline = "L_AS", group = g_LABELS)
as_alert            = input.bool(false, "Alerts", inline = "L_AS", group = g_LABELS)

loh_str             = input.string("LO.H", "Session 2 Labels", inline = "L_LO", group = g_LABELS)
lol_str             = input.string("LO.L", "", inline = "L_LO", group = g_LABELS)
lo_alert            = input.bool(false, "Alerts", inline = "L_LO", group = g_LABELS)

nah_str             = input.string("NYAM.H", "Session 3 Labels", inline = "L_NA", group = g_LABELS)
nal_str             = input.string("NYAM.L", "", inline = "L_NA", group = g_LABELS)
na_alert            = input.bool(false, "Alerts", inline = "L_NA", group = g_LABELS)

nlh_str             = input.string("NYL.H", "Session 4 Labels", inline = "L_NL", group = g_LABELS)
nll_str             = input.string("NYL.L", "", inline = "L_NL", group = g_LABELS)
nl_alert            = input.bool(false, "Alerts", inline = "L_NL", group = g_LABELS)

nph_str             = input.string("NYPM.H", "Session 5 Labels", inline = "L_NP", group = g_LABELS)
npl_str             = input.string("NYPM.L", "", inline = "L_NP", group = g_LABELS)
np_alert            = input.bool(false, "Alerts", inline = "L_NP", group = g_LABELS)

s_style             = input.string(defval = 'Solid', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "L_0", group = g_LABELS)
s_width             = input.int(1, "", inline = "L_0", group = g_LABELS)


var g_DWM           = "DWM Open"
dow_labels          = input.bool(true, "Day of Week Labels", inline = "DOW", group = g_DWM)
dow_yloc            = input.string('Bottom', "", options = ['Top', 'Bottom'], inline = "DOW", group = g_DWM)
dow_xloc            = input.string('Midnight', "", options = ['Midnight', 'Midday'], inline = "DOW", group = g_DWM)
dow_color           = input.color(color.black, "", inline = "DOW", group = g_DWM)

show_d_open         = input.bool(false, "", inline = "DO", group = g_DWM)
d_open_str          = input.string("D.OPEN", "", inline = "DO", group = g_DWM)
ds                  = input.bool(false, "Separators", inline = "DO", tooltip = "Mark where a new day begins. Unlimited will override the drawing limit", group = g_DWM)
ds_unlimited        = input.bool(true, "Unlimited", inline = "DO", group = g_DWM)
d_color             = input.color(color.blue, "", inline = "DO", group = g_DWM)

show_w_open         = input.bool(false, "", inline = "WO", group = g_DWM)
w_open_str          = input.string("W.OPEN", "", inline = "WO", group = g_DWM)
ws                  = input.bool(false, "Separators", inline = "WO", tooltip = "Mark where a new week begins. Unlimited will override the drawing limit", group = g_DWM)
ws_unlimited        = input.bool(true, "Unlimited", inline = "WO", group = g_DWM)
w_color             = input.color(#089981, "", inline = "WO", group = g_DWM)

show_m_open         = input.bool(false, "", inline = "MO", group = g_DWM)
m_open_str          = input.string("M.OPEN", "", inline = "MO", group = g_DWM)
ms                  = input.bool(false, "Separators", inline = "MO", tooltip = "Mark where a new month begins. Unlimited will override the drawing limit", group = g_DWM)
ms_unlimited        = input.bool(true, "Unlimited", inline = "MO", group = g_DWM)
m_color             = input.color(color.red, "", inline = "MO", group = g_DWM)

dwm_style           = input.string(defval = 'Solid', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "D0", group = g_DWM)
dwm_width           = input.int(1, "", inline = "D0", group = g_DWM)


var g_OPEN          = "Opening Price"
use_h1              = input.bool(true, "", inline = "H1", group = g_OPEN)
h1_text             = input.string("True Day Open", "", inline = "H1", group = g_OPEN)
h1                  = input.session("0000-0001", "", inline = "H1", group = g_OPEN)
h1_color            = input.color(color.black, "", inline = "H1", group = g_OPEN)

use_h2              = input.bool(false, "", inline = "H2", group = g_OPEN)
h2_text             = input.string("06:00", "", inline = "H2", group = g_OPEN)
h2                  = input.session("0600-0601", "", inline = "H2", group = g_OPEN)
h2_color            = input.color(color.black, "", inline = "H2", group = g_OPEN)

use_h3              = input.bool(false, "", inline = "H3", group = g_OPEN)
h3_text             = input.string("10:00", "", inline = "H3", group = g_OPEN)
h3                  = input.session("1000-1001", "", inline = "H3", group = g_OPEN)
h3_color            = input.color(color.black, "", inline = "H3", group = g_OPEN)

use_h4              = input.bool(false, "", inline = "H4", group = g_OPEN)
h4_text             = input.string("14:00", "", inline = "H4", group = g_OPEN)
h4                  = input.session("1400-1401", "", inline = "H4", group = g_OPEN)
h4_color            = input.color(color.black, "", inline = "H4", group = g_OPEN)

h_style             = input.string(defval = 'Dotted', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "H0", group = g_OPEN)
h_width             = input.int(1, "", inline = "H0", group = g_OPEN)


var g_VERTICAL      = "Timestamps"
use_v1              = input.bool(false, "", inline = "V1", group = g_VERTICAL)
v1                  = input.session("0000-0001", "", inline = "V1", group = g_VERTICAL)
v1_color            = input.color(color.black, "", inline = "V1", group = g_VERTICAL)

use_v2              = input.bool(false, "", inline = "V2", group = g_VERTICAL)
v2                  = input.session("0800-0801", "", inline = "V2", group = g_VERTICAL)
v2_color            = input.color(color.black, "", inline = "V2", group = g_VERTICAL)

use_v3              = input.bool(false, "", inline = "V3", group = g_VERTICAL)
v3                  = input.session("1000-1001", "", inline = "V3", group = g_VERTICAL)
v3_color            = input.color(color.black, "", inline = "V3", group = g_VERTICAL)

use_v4              = input.bool(true, "", inline = "V4", group = g_VERTICAL)
v4                  = input.session("1200-1201", "", inline = "V4", group = g_VERTICAL)
v4_color            = input.color(color.black, "", inline = "V4", group = g_VERTICAL)

v_style             = input.string(defval = 'Dotted', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "V0", group = g_VERTICAL)
v_width             = input.int(1, "", inline = "V0", group = g_VERTICAL)
// ---------------------------------------- Inputs --------------------------------------------------


// ---------------------------------------- Variables & Constants --------------------------------------------------
t_as = not na(time("", asia, gmt_tz))
t_lo = not na(time("", london, gmt_tz))
t_na = not na(time("", nyam, gmt_tz))
t_nl = not na(time("", nylu, gmt_tz))
t_np = not na(time("", nypm, gmt_tz))
t_co = not na(time("", cutoff, gmt_tz))

t_h1 = not na(time("", h1, gmt_tz))
t_h2 = not na(time("", h2, gmt_tz))
t_h3 = not na(time("", h3, gmt_tz))
t_h4 = not na(time("", h4, gmt_tz))

t_v1 = not na(time("", v1, gmt_tz))
t_v2 = not na(time("", v2, gmt_tz))
t_v3 = not na(time("", v3, gmt_tz))
t_v4 = not na(time("", v4, gmt_tz))

var as_hi_line = array.new_line()
var as_lo_line = array.new_line()
var lo_hi_line = array.new_line()
var lo_lo_line = array.new_line()
var na_hi_line = array.new_line()
var na_lo_line = array.new_line()
var nl_hi_line = array.new_line()
var nl_lo_line = array.new_line()
var np_hi_line = array.new_line()
var np_lo_line = array.new_line()

var d_sep_line = array.new_line()
var w_sep_line = array.new_line()
var m_sep_line = array.new_line()

var d_line = array.new_line()
var w_line = array.new_line()
var m_line = array.new_line()

var h1_line = array.new_line()
var h2_line = array.new_line()
var h3_line = array.new_line()
var h4_line = array.new_line()

var v1_line = array.new_line()
var v2_line = array.new_line()
var v3_line = array.new_line()
var v4_line = array.new_line()

var d_label = array.new_label()
var w_label = array.new_label()
var m_label = array.new_label()

var h1_label = array.new_label()
var h2_label = array.new_label()
var h3_label = array.new_label()
var h4_label = array.new_label()

var as_hi_label = array.new_label()
var as_lo_label = array.new_label()
var lo_hi_label = array.new_label()
var lo_lo_label = array.new_label()
var na_hi_label = array.new_label()
var na_lo_label = array.new_label()
var nl_hi_label = array.new_label()
var nl_lo_label = array.new_label()
var np_hi_label = array.new_label()
var np_lo_label = array.new_label()

var as_box = array.new_box()
var lo_box = array.new_box()
var na_box = array.new_box()
var nl_box = array.new_box()
var np_box = array.new_box()

transparent = #ffffff00

d_o = request.security(syminfo.tickerid, "D", open, barmerge.gaps_off, barmerge.lookahead_on)
w_o = request.security(syminfo.tickerid, "W", open, barmerge.gaps_off, barmerge.lookahead_on)
m_o = request.security(syminfo.tickerid, "M", open, barmerge.gaps_off, barmerge.lookahead_on)
// ---------------------------------------- Variables & Constants --------------------------------------------------


// ---------------------------------------- Functions --------------------------------------------------
get_label_size(_size) =>
    result = switch _size
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal
        'Large' => size.large
        'Huge' => size.huge
        'Auto' => size.auto
    result

get_line_type(_style) =>
    result = switch _style
        'Solid' => line.style_solid
        'Dotted' => line.style_dotted
        'Dashed' => line.style_dashed
    result

get_box_color(_color, _transparency) =>
    result = color.new(_color, _transparency)
    
adjust(_hline, _lline, _hlabel, _llabel, _ulabel, _box) =>
    _hline.set_x2(bar_index)
    _lline.set_x2(bar_index)
    _box.set_right(bar_index)

    _top = show_kz ? _box.get_top() : _hline.get_y1()
    _bot = show_kz ? _box.get_bottom() : _lline.get_y1()

    if high > _top
        _hline.set_xy1(bar_index, high)
        _hline.set_y2(high)
        _box.set_top(high)

        _hlabel.set_x(bar_index)
        _hlabel.set_y(high)
    if low < _bot
        _lline.set_xy1(bar_index, low)
        _lline.set_y2(low)
        _box.set_bottom(low)

        _llabel.set_x(bar_index)
        _llabel.set_y(low)

check_high(_line) =>
    result = false
    broke = false
    _line.set_x2(bar_index)
    if high > _line.get_y1()
        result := true
        broke := true
    else if  (use_cutoff ? t_co : false)
        result := true
    [result, broke]
    
check_low(_line) =>
    result = false
    broke = false
    _line.set_x2(bar_index)
    if low < _line.get_y1()
        result := true
        broke := true
    else if (use_cutoff ? t_co : false)
        result := true
    [result, broke]
    
check_open(_line, _label) =>
    result = false
    _line.set_x2(bar_index)
    _label.set_x(bar_index)
    if (use_cutoff ? t_co : false)
        result := true
    result

check_array(_arr) =>
    if _arr.size() > max_days
        _arr.pop().delete()
// ---------------------------------------- Functions --------------------------------------------------


// ---------------------------------------- Core Logic --------------------------------------------------
s_style := get_line_type(s_style)
dwm_style := get_line_type(dwm_style)
h_style := get_line_type(h_style)
v_style := get_line_type(v_style)

lb_size := get_label_size(lb_size)

var color as_box_color = get_box_color(as_color, box_transparency)
var color lo_box_color = get_box_color(lo_color, box_transparency)
var color na_box_color = get_box_color(na_color, box_transparency)
var color nl_box_color = get_box_color(nl_color, box_transparency)
var color np_box_color = get_box_color(np_color, box_transparency)

var color as_text_color = get_box_color(as_color, text_transparency)
var color lo_text_color = get_box_color(lo_color, text_transparency)
var color na_text_color = get_box_color(na_color, text_transparency)
var color nl_text_color = get_box_color(nl_color, text_transparency)
var color np_text_color = get_box_color(np_color, text_transparency)

var h1_co = false
var h2_co = false
var h3_co = false
var h4_co = false

var as_stop_hi = false
var as_stop_lo = false

var lo_stop_hi = false
var lo_stop_lo = false

var na_stop_hi = false
var na_stop_lo = false

var nl_stop_hi = false
var nl_stop_lo = false

var np_stop_hi = false
var np_stop_lo = false

as_broke_hi = false
as_broke_lo = false

lo_broke_hi = false
lo_broke_lo = false

na_broke_hi = false
na_broke_lo = false

nl_broke_hi = false
nl_broke_lo = false

np_broke_hi = false
np_broke_lo = false

// day_str = switch dayofweek

// if dayofweek != dayofweek[1]
//     label.new(time, high, str.tostring(dayofweek))

if timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit)
    // Asia
    if use_asia
        if t_as and not t_as[1]
            as_stop_hi := false
            as_stop_lo := false

            if show_kz
                as_box.unshift(box.new(bar_index, high, bar_index, low, border_color = as_box_color, bgcolor = as_box_color, text = show_kz_text ? asia_text : na, text_color = as_text_color))

            if show_pivots
                as_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = as_color, width = s_width))
                as_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = as_color, width = s_width))

            if show_labels
                as_hi_label.unshift(label.new(bar_index, high, ash_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                as_lo_label.unshift(label.new(bar_index, low, asl_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_as
            adjust(show_pivots ? as_hi_line.get(0) : na, show_pivots ? as_lo_line.get(0) : na, show_labels ? as_hi_label.get(0) : na, show_labels ? as_lo_label.get(0) : na, show_labels, show_kz ? as_box.get(0) : na)
        else if not t_as and as_hi_line.size() > 0
            if not as_stop_hi
                [_r, _b] = check_high(as_hi_line.get(0))
                if _r
                    as_stop_hi := true
                if _b
                    as_broke_hi := true
                    if as_alert
                        alert("Broke " + str.tostring(ash_str), alert.freq_once_per_bar)
            if not as_stop_lo
                [_r, _b] = check_low(as_lo_line.get(0))
                if _r
                    as_stop_lo := true
                if _b
                    as_broke_lo := true
                    if as_alert
                        alert("Broke " + str.tostring(asl_str), alert.freq_once_per_bar)
        
    // London
    if use_london
        if t_lo and not t_lo[1]
            lo_stop_hi := false
            lo_stop_lo := false

            if show_kz
                lo_box.unshift(box.new(bar_index, high, bar_index, low, border_color = lo_box_color, bgcolor = lo_box_color, text = show_kz_text ? london_text : na, text_color = lo_text_color))

            if show_pivots
                lo_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = lo_color, width = s_width))
                lo_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = lo_color, width = s_width))

            if show_labels
                lo_hi_label.unshift(label.new(bar_index, high, loh_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                lo_lo_label.unshift(label.new(bar_index, low, lol_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_lo
            adjust(show_pivots ? lo_hi_line.get(0) : na, show_pivots ? lo_lo_line.get(0) : na, show_labels ? lo_hi_label.get(0) : na, show_labels ? lo_lo_label.get(0) : na, show_labels, show_kz ? lo_box.get(0) : na)
        else if not t_lo and lo_hi_line.size() > 0
            if not lo_stop_hi
                [_r, _b] = check_high(lo_hi_line.get(0))
                if _r
                    lo_stop_hi := true
                if _b
                    lo_broke_hi := true
                    if lo_alert
                        alert("Broke " + str.tostring(loh_str), alert.freq_once_per_bar)
            if not lo_stop_lo
                [_r, _b] = check_low(lo_lo_line.get(0))
                if _r
                    lo_stop_lo := true
                if _b
                    lo_broke_lo := true
                    if lo_alert
                        alert("Broke " + str.tostring(lol_str), alert.freq_once_per_bar)
                        
    // NY AM
    if use_nyam
        if t_na and not t_na[1]
            na_stop_hi := false
            na_stop_lo := false

            if show_kz
                na_box.unshift(box.new(bar_index, high, bar_index, low, border_color = na_box_color, bgcolor = na_box_color, text = show_kz_text ? nyam_text : na, text_color = na_text_color))

            if show_pivots
                na_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = na_color, width = s_width))
                na_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = na_color, width = s_width))

            if show_labels
                na_hi_label.unshift(label.new(bar_index, high, nah_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                na_lo_label.unshift(label.new(bar_index, low, nal_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_na
            adjust(show_pivots ? na_hi_line.get(0) : na, show_pivots ? na_lo_line.get(0) : na, show_labels ? na_hi_label.get(0) : na, show_labels ? na_lo_label.get(0) : na, show_labels, show_kz ? na_box.get(0) : na)
        else if not t_na and na_hi_line.size() > 0
            if not na_stop_hi
                [_r, _b] = check_high(na_hi_line.get(0))
                if _r
                    na_stop_hi := true
                if _b
                    na_broke_hi := true
                    if na_alert
                        alert("Broke " + str.tostring(nah_str), alert.freq_once_per_bar)
            if not na_stop_lo
                [_r, _b] = check_low(na_lo_line.get(0))
                if _r
                    na_stop_lo := true
                if _b
                    na_broke_lo := true
                    if na_alert
                        alert("Broke " + str.tostring(nal_str), alert.freq_once_per_bar)
                        
    // NY Lunch
    if use_nylu
        if t_nl and not t_nl[1]
            nl_stop_hi := false
            nl_stop_lo := false

            if show_kz
                nl_box.unshift(box.new(bar_index, high, bar_index, low, border_color = nl_box_color, bgcolor = nl_box_color, text = show_kz_text ? nylu_text : na, text_color = nl_text_color))

            if show_pivots
                nl_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = nl_color, width = s_width))
                nl_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = nl_color, width = s_width))

            if show_labels
                nl_hi_label.unshift(label.new(bar_index, high, nlh_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                nl_lo_label.unshift(label.new(bar_index, low, nll_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_nl
            adjust(show_pivots ? nl_hi_line.get(0) : na, show_pivots ? nl_lo_line.get(0) : na, show_labels ? nl_hi_label.get(0) : na, show_labels ? nl_lo_label.get(0) : na, show_labels, show_kz ? nl_box.get(0) : na)
        else if not t_nl and nl_hi_line.size() > 0
            if not nl_stop_hi
                [_r, _b] = check_high(nl_hi_line.get(0))
                if _r
                    nl_stop_hi := true
                if _b
                    nl_broke_hi := true
                    if nl_alert
                        alert("Broke " + str.tostring(nlh_str), alert.freq_once_per_bar)
            if not nl_stop_lo
                [_r, _b] = check_low(nl_lo_line.get(0))
                if _r
                    nl_stop_lo := true
                if _b
                    nl_broke_lo := true
                    if nl_alert
                        alert("Broke " + str.tostring(nll_str), alert.freq_once_per_bar)
                        
    // NY PM
    if use_nypm
        if t_np and not t_np[1]
            np_stop_hi := false
            np_stop_lo := false

            if show_kz
                np_box.unshift(box.new(bar_index, high, bar_index, low, border_color = np_box_color, bgcolor = np_box_color, text = show_kz_text ? nypm_text : na, text_color = np_text_color))

            if show_pivots
                np_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = np_color, width = s_width))
                np_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = np_color, width = s_width))

            if show_labels
                np_hi_label.unshift(label.new(bar_index, high, nph_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                np_lo_label.unshift(label.new(bar_index, low, npl_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_np
            adjust(show_pivots ? np_hi_line.get(0) : na, show_pivots ? np_lo_line.get(0) : na, show_labels ? np_hi_label.get(0) : na, show_labels ? np_lo_label.get(0) : na, show_labels, show_kz ? np_box.get(0) : na) 
        else if not t_np and np_hi_line.size() > 0
            if not np_stop_hi
                [_r, _b] = check_high(np_hi_line.get(0))
                if _r
                    np_stop_hi := true
                if _b
                    np_broke_hi := true
                    if np_alert
                        alert("Broke " + str.tostring(nph_str), alert.freq_once_per_bar)
            if not np_stop_lo
                [_r, _b] = check_low(np_lo_line.get(0))
                if _r
                    np_stop_lo := true
                if _b
                    np_broke_lo := true
                    if np_alert
                        alert("Broke " + str.tostring(npl_str), alert.freq_once_per_bar)
                
    // Vertical Lines
    if use_v1
        if t_v1 and not t_v1[1]
            v1_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v1_color))
    if use_v2
        if t_v2 and not t_v2[1]
            v2_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v2_color))
    if use_v3
        if t_v3 and not t_v3[1]
            v3_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v3_color))
    if use_v4
        if t_v4 and not t_v4[1]
            v4_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v4_color))

    // Horizontal Lines
    if use_h1
        if t_h1 and not t_h1[1]
            h1_co := false
            
            h1_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h1_color))
            h1_label.unshift(label.new(bar_index, open, h1_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h1 and h1_line.size() > 0
            if not h1_co
                if not check_open(h1_line.get(0), h1_label.get(0))
                    h1_label.get(0).set_x(bar_index)
                else
                    h1_co := true
                
    if use_h2
        if t_h2 and not t_h2[1]
            h2_co := false
            
            h2_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h2_color))
            h2_label.unshift(label.new(bar_index, open, h2_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h2 and h2_line.size() > 0
            if not h2_co 
                if not check_open(h2_line.get(0), h2_label.get(0))
                    h2_label.get(0).set_x(bar_index)
                else
                    h2_co := true
                
    if use_h3
        if t_h3 and not t_h3[1]
            h3_co := false
            
            h3_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h3_color))
            h3_label.unshift(label.new(bar_index, open, h3_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h3 and h3_line.size() > 0
            if not h3_co
                if not check_open(h3_line.get(0), h3_label.get(0))
                    h3_label.get(0).set_x(bar_index)
                else
                    h3_co := true
                
    if use_h4
        if t_h4 and not t_h4[1]
            h4_co := false
            
            h4_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h4_color))
            h4_label.unshift(label.new(bar_index, open, h4_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h4 and h4_line.size() > 0
            if not h4_co
                if not check_open(h4_line.get(0), h4_label.get(0))
                    h4_label.get(0).set_x(bar_index)
                else
                    h4_co := true

    // DWM - Separators
    if ds
        if d_o != d_o[1]
            d_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = d_color))
    if ws
        if w_o != w_o[1]
            w_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = w_color))
    if ms
        if m_o != m_o[1]
            m_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = m_color))

    // DWM - Open Lines
    if show_d_open
        if d_o != d_o[1]
            d_line.unshift(line.new(bar_index, d_o, bar_index, d_o, style = dwm_style, width = dwm_width, color = d_color))
            d_label.unshift(label.new(bar_index, d_o, d_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if d_line.size() > 0
            if not check_open(d_line.get(0), d_label.get(0))
                d_label.get(0).set_x(bar_index)
                
    if show_w_open
        if w_o != w_o[1]
            w_line.unshift(line.new(bar_index, w_o, bar_index, w_o, style = dwm_style, width = dwm_width, color = w_color))
            w_label.unshift(label.new(bar_index, w_o, w_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if w_line.size() > 0
            if not check_open(w_line.get(0), w_label.get(0))
                w_label.get(0).set_x(bar_index)
                
    if show_m_open
        if m_o != m_o[1]
            m_line.unshift(line.new(bar_index, m_o, bar_index, m_o, style = dwm_style, width = dwm_width, color = m_color))
            m_label.unshift(label.new(bar_index, m_o, m_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if m_line.size() > 0
            if not check_open(m_line.get(0), m_label.get(0))
                m_label.get(0).set_x(bar_index)

new_dow_time = dow_xloc == 'Midday' ? time - timeframe.in_seconds("D") / 2 * 1000 : time
new_day = dayofweek(new_dow_time, gmt_tz) != dayofweek(new_dow_time, gmt_tz)[1]
dow_top = dow_yloc == 'Top'

monday = "MONDAY"
tuesday = "TUESDAY"
wednesday = "WEDNESDAY"
thursday = "THURSDAY"
friday = "FRIDAY"

plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 2 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = monday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 3 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = tuesday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 4 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = wednesday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 5 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = thursday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 6 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = friday)

check_array(as_hi_line)
check_array(as_lo_line)
check_array(as_hi_label)
check_array(as_lo_label)
check_array(as_box)

check_array(lo_hi_line)
check_array(lo_lo_line)
check_array(lo_hi_label)
check_array(lo_lo_label)
check_array(lo_box)

check_array(na_hi_line)
check_array(na_lo_line)
check_array(na_hi_label)
check_array(na_lo_label)
check_array(na_box)

check_array(nl_hi_line)
check_array(nl_lo_line)
check_array(nl_hi_label)
check_array(nl_lo_label)
check_array(nl_box)

check_array(np_hi_line)
check_array(np_lo_line)
check_array(np_hi_label)
check_array(np_lo_label)
check_array(np_box)

check_array(v1_line)
check_array(v2_line)
check_array(v3_line)
check_array(v4_line)

check_array(h1_line)
check_array(h2_line)
check_array(h3_line)
check_array(h4_line)

check_array(h1_label)
check_array(h2_label)
check_array(h3_label)
check_array(h4_label)

if not ds_unlimited
    check_array(d_sep_line)
    check_array(d_line)
    check_array(d_label)
if not ws_unlimited
    check_array(w_sep_line)
    check_array(w_line)
    check_array(w_label)
if not ms_unlimited
    check_array(m_sep_line)
    check_array(m_line)
    check_array(m_label)
// ---------------------------------------- Core Logic --------------------------------------------------

//------------------------------------------macros start---------------------------------------------------

//#region[GLOBAL]
var line[]  EXT = array.new_line()
var label[] LBL = array.new_label()
oneDayMS        = 86400000
oneBarMS        = time_close-time
noColor         =color.new(#ffffff,100)
len = timeframe.in_seconds(timeframe.period) < timeframe.in_seconds("30") ? 
      math.max(1, int(timeframe.in_seconds("15") / timeframe.in_seconds(timeframe.period))) : na

one = na(len) ? na : ta.highest(len) + syminfo.mintick * 10
y_btm_Line1     = one
y_top_Line1     = one+syminfo.mintick*5
//#endregion


//#region[INPUTS]
_macroC =  input.color(color.new(#000000,0),  title="Macro Color",        inline='main')
_mode   = input.string("On Chart",              title="",                   inline='main', options=["On Chart", "New Pane"], tooltip='When "New Pane" is selected, make sure you move the indicator to a New Pane as well, it is not automatic.')

_showL  =   input.bool(true,                    title="Macro Label?",       inline='sh')
_mTxt   =   input.bool(false,                   title="Show Time?",         inline='sh')
_extt   =	input.bool(false,                   title="Macro Projections?", inline='sh', tooltip='Extends On Chart Macro lines towards price.')

_bgm    =  input.color(color.new(#4caf50,70), title="Macro Color",     inline='bc',     tooltip='Visible only in "New Pane" mode')
//#endregion


//#region[FUNCTIONS]
time_isMacro(int H_start, int M_start, int H_end, int M_end) =>
    h = hour(time, "America/New_York")
    m = minute(time, "America/New_York")
	h==H_start ? (H_start!=H_end ? m>=M_start : m>=M_start and m<M_end) : (h>H_start ? (h==H_end ? m<M_end : h<H_end) : false)


_controlMacroLine(line[] _lines, label[] _lbl, bool _time) =>
	if _time
		_lbl.last().set_x(math.round(math.avg(_lines.get(_lines.size()-2).get_x1(),time)))
		if high>_lines.last().get_y2()-syminfo.mintick*10
			_lines.get(_lines.size()-2).set_y2(high+(syminfo.mintick*10))
			_lines.last().set_y1(high+(syminfo.mintick*10))
			_lines.last().set_y2(high+(syminfo.mintick*10))
			LBL.last().set_y(high+(syminfo.mintick*10))
		if na or _lines.last().get_x2() == time
			_lines.last().set_x2(time+oneBarMS)

_controlMacroBox(box[] _boxes, bool _time, bool _friday) =>
	dly = _friday?oneDayMS*3:oneDayMS
	if na or _time
		_boxes.last().set_right(time+dly)

method memoryCleanLine(line[] A) =>
	if A.size()>300
		for i=0 to 3
			A.shift().delete()
method memoryCleanLabel(label[] A) =>
	if A.size()>100
		A.shift().delete()

macroOC(line[] LINES, bool _time, string _kzTime, bool _friday)=>
	dly  = _friday?oneDayMS*3:oneDayMS
	_txt = _mTxt?"MACRO"+"\n"+_kzTime:"MACRO"
	_tt  = "MACRO\n"+_kzTime

	// Overlay False
	if not _time[1] and _time
		_vline1 = line.new(time,y_btm_Line1,time,y_top_Line1,xloc=xloc.bar_time,color=_macroC)
		LINES.push(_vline1)
		_hline = line.new(time,y_top_Line1,time+oneBarMS,y_top_Line1,xloc=xloc.bar_time,color=_macroC)
		LINES.push(_hline)
		if _extt
			EXT.push(line.new(time,high,time,_vline1.get_y2(),xloc=xloc.bar_time,color=_macroC,style=line.style_dotted))

		if _mode=="On Chart"
			LBL.push(label.new(time
							 , LINES.get(LINES.size()-2).get_y2()
							 , _showL?_txt:""
							 , tooltip=_tt
							 , xloc=xloc.bar_time
							 , style=label.style_label_down
							 , color=noColor
							 , textcolor=_macroC
							 , size=size.small))

	if _time[1] and not _time and LINES.size()>0 and LBL.size()>0
		_vline2 = line.new(time,y_btm_Line1,time,y_top_Line1,xloc=xloc.bar_time,color=_macroC)
		LBL.last().set_x(math.round(math.avg(LINES.get(LINES.size()-2).get_x1(),time)))
		if y_top_Line1 > LINES.get(LINES.size()-2).get_y2()
			LINES.get(LINES.size()-2).set_y2(y_top_Line1)
			LINES.last().set_y1(y_top_Line1)
			LINES.last().set_y2(y_top_Line1)
			LBL.last().set_y(y_top_Line1)
		else if y_top_Line1 < LINES.get(LINES.size()-2).get_y2()
			_vline2.set_y2(LINES.get(LINES.size()-2).get_y2())
		if _extt
			EXT.push(line.new(time,high,time,_vline2.get_y2(),xloc=xloc.bar_time,color=_macroC,style=line.style_dotted))

		LINES.push(_vline2)

	if LINES.size()>0 and LBL.size()>0
		_controlMacroLine(LINES, LBL, _time)
		

macroNP(box[] BOXES, bool _time, string _kzTime, bool _friday)=>
	dly  = _friday?86400000*3:86400000
	_col = _bgm
	_tt  = "MACRO\n"+_kzTime
	end  = not _time and _time[1]

	// Overlay False
	var _plotNP = false
	if not _time[1] and _time
		_macro = box.new(time+dly,2,time+dly,0,_macroC,xloc=xloc.bar_time,bgcolor=_col)
		BOXES.push(_macro)
		_plotNP := true

	if _time[1] and not _time and BOXES.size()>0
		_controlMacroBox(BOXES, true, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
		_plotNP := false
		macroL = label.new(math.round(math.avg(BOXES.last().get_left(),BOXES.last().get_right()))
					     , 1
						 , xloc=xloc.bar_time
						 , style=label.style_label_center
						 , color=noColor
						 , tooltip=_tt
						 , text='ⓘ\n\n\n\n\n\n'
						 , textcolor=_macroC
						 , size=size.small)

	if _time and _plotNP
		_controlMacroBox(BOXES, _time, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
//#endregion


//#region[LOGIC]
show1              = input.bool(false, title="00:50 - 01:10", group="Hourly Macros")
var line[] _LINES1 = array.new_line()
var box[] _BOXES1  = array.new_box()
time1              = time_isMacro(0, 50, 1, 10)
lbl1               = "00:50 - 1:10"

show2              = input.bool(false, title="01:50 - 02:10", group="Hourly Macros")
var line[] _LINES2 = array.new_line()
var box[] _BOXES2  = array.new_box()
time2              = time_isMacro(1, 50, 2, 10)
lbl2               = "1:50 - 2:10"

show3              = input.bool(true, title="02:50 - 03:10", group="Hourly Macros")
var line[] _LINES3 = array.new_line()
var box[] _BOXES3  = array.new_box()
time3              = time_isMacro(2, 50, 3, 10)
lbl3               = "2:50 - 3:10"

show4              = input.bool(true, title="03:50 - 04:10", group="Hourly Macros")
var line[] _LINES4 = array.new_line()
var box[] _BOXES4  = array.new_box()
time4              = time_isMacro(3, 50, 4, 10)
lbl4               = "3:50 - 4:10"

show5              = input.bool(true, title="04:50 - 05:10", group="Hourly Macros")
var line[] _LINES5 = array.new_line()
var box[] _BOXES5  = array.new_box()
time5              = time_isMacro(4, 50, 5, 10)
lbl5               = "4:50 - 5:10"

show6              = input.bool(false, title="05:50 - 06:10", group="Hourly Macros")
var line[] _LINES6 = array.new_line()
var box[] _BOXES6  = array.new_box()
time6              = time_isMacro(5, 50, 6, 10)
lbl6               = "5:50 - 6:10"

show7              = input.bool(false, title="06:50 - 07:10", group="Hourly Macros")
var line[] _LINES7 = array.new_line()
var box[] _BOXES7  = array.new_box()
time7              = time_isMacro(6, 50, 7, 10)
lbl7               = "6:50 - 7:10"

show8              = input.bool(false, title="07:50 - 08:10", group="Hourly Macros")
var line[] _LINES8 = array.new_line()
var box[] _BOXES8  = array.new_box()
time8              = time_isMacro(7, 50, 8, 10)
lbl8               = "7:50 - 8:10"

show9              = input.bool(false, title="08:50 - 09:10", group="Hourly Macros")
var line[] _LINES9 = array.new_line()
var box[] _BOXES9  = array.new_box()
time9              = time_isMacro(8, 50, 9, 10)
lbl9               = "8:50 - 9:10"

show10              = input.bool(true, title="09:50 - 10:10", group="Hourly Macros")
var line[] _LINES10 = array.new_line()
var box[] _BOXES10  = array.new_box()
time10              = time_isMacro(9, 50, 10, 10)
lbl10               = "9:50 - 10:10"

show11              = input.bool(true, title="10:50 - 11:10", group="Hourly Macros")
var line[] _LINES11 = array.new_line()
var box[] _BOXES11  = array.new_box()
time11              = time_isMacro(10, 50, 11, 10)
lbl11               = "10:50 - 11:10"

show12              = input.bool(true, title="11:50 - 12:10", group="Hourly Macros")
var line[] _LINES12 = array.new_line()
var box[] _BOXES12  = array.new_box()
time12              = time_isMacro(11, 50, 12, 10)
lbl12               = "11:50 - 12:10"

show13              = input.bool(true, title="12:50 - 13:10", group="Hourly Macros")
var line[] _LINES13 = array.new_line()
var box[] _BOXES13  = array.new_box()
time13              = time_isMacro(12, 50, 13, 10)
lbl13               = "12:50 - 13:10"

show14              = input.bool(true, title="13:50 - 14:10", group="Hourly Macros")
var line[] _LINES14 = array.new_line()
var box[] _BOXES14  = array.new_box()
time14              = time_isMacro(13, 50, 14, 10)
lbl14               = "13:50 - 14:10"

show17              = input.bool(false, title="16:50 - 17:10", group="Hourly Macros")
var line[] _LINES17 = array.new_line()
var box[] _BOXES17  = array.new_box()
time17              = time_isMacro(16, 50, 17, 10)
lbl17               = "16:50 - 17:10"

show18              = input.bool(false, title="17:50 - 18:10", group="Hourly Macros")
var line[] _LINES18 = array.new_line()
var box[] _BOXES18  = array.new_box()
time18              = time_isMacro(17, 50, 18, 10)
lbl18               = "17:50 - 18:10"

show19              = input.bool(false, title="18:50 - 19:10", group="Hourly Macros")
var line[] _LINES19 = array.new_line()
var box[] _BOXES19  = array.new_box()
time19              = time_isMacro(18, 50, 19, 10)
lbl19               = "18:50 - 19:10"

show20              = input.bool(false, title="19:50 - 20:10", group="Hourly Macros")
var line[] _LINES20 = array.new_line()
var box[] _BOXES20  = array.new_box()
time20              = time_isMacro(19, 50, 20, 10)
lbl20               = "19:50 - 20:10"

show21              = input.bool(false, title="20:50 - 21:10", group="Hourly Macros")
var line[] _LINES21 = array.new_line()
var box[] _BOXES21  = array.new_box()
time21              = time_isMacro(20, 50, 21, 10)
lbl21               = "20:50 - 21:10"

show22              = input.bool(false, title="21:50 - 22:10", group="Hourly Macros")
var line[] _LINES22 = array.new_line()
var box[] _BOXES22  = array.new_box()
time22              = time_isMacro(21, 50, 22, 10)
lbl22               = "21:50 - 22:10"

show23              = input.bool(false, title="22:50 - 23:10", group="Hourly Macros")
var line[] _LINES23 = array.new_line()
var box[] _BOXES23  = array.new_box()
time23              = time_isMacro(22, 50, 23, 10)
lbl23               = "22:50 - 23:10"

show24              = input.bool(false, title="23:50 - 00:10", group="Hourly Macros")
var line[] _LINES24 = array.new_line()
var box[] _BOXES24  = array.new_box()
time24              = time_isMacro(23, 50, 0, 10)
lbl24               = "23:50 - 00:10"


show15              = input.bool(true, title="14:50 - 15:10", group="Last Hour NY PM Macros")
var line[] _LINES15 = array.new_line()
var box[] _BOXES15  = array.new_box()
time15              = time_isMacro(14, 50, 15, 10)
lbl15               = "14:50 - 15:10"

showPM1              = input.bool(true, title="15:15 - 15:45", group="Last Hour NY PM Macros")
var line[] _LINESPM1 = array.new_line()
var box[] _BOXESPM1  = array.new_box()
timePM1              = time_isMacro(15, 15, 15, 45)
lblPM1               = "15:15 - 15:45"

show16              = input.bool(true, title="15:50 - 16:10", group="Last Hour NY PM Macros")
var line[] _LINES16 = array.new_line()
var box[] _BOXES16  = array.new_box()
time16              = time_isMacro(15, 50, 16, 10)
lbl16               = "15:50 - 16:10"

// 																		                        //\//////////////////////////////////////////////////////////////////////////////////////////////////////////////\///
//                                                                                              //  INSTRUCTIONS TO ADD CUSTOM MACROs (PART 1):                                                                    //
//                                                                                              //  1.1) Copy these four lines of code and add them below the instruction box -> // CUSTOM MACROS;                 //
// var line[] _lines_YourMacroName = array.new_line()                                           //       Make sure the text is not gray like these instructions. To do that, remove the '//' in front.             //
// var box[] _boxes_YourMacroName  = array.new_box()                                            //  1.2) Replace 'YourMacroName' with whatever you want in these four lines.                                       //
// _time_YourMacroName            = time_isMacro(startHour, startMinute, endHour, endMinute)    //  1.3) Add your macro time window in the format: "hhmm-hhmm:1234567"                                             //
// _lbl_YourMacroName             = "hh:mm - hh:mm"                                             //  1.4) Add your macro time text in _lbl_YourMacroName, this will be displayed in the tooltips,                   //
// 																		                        //       and in the MACRO label on chart, if toggled on.                                                           //
// 																		                        //                                                                                                                 //
// 																		                        ///\//////////////////////////////////////////.   PART 2 BELOW   .////////////////////////////////////////////////\//

// CUSTOM MACROS
// Your custom macros go here
//#endregion


//#region[PLOT]
if _mode=="On Chart"
	if show1
		macroOC(_LINES1, time1, lbl1, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //\////////////////////////////////////////////////////////////////////////////\///
	if show2																							  //  INSTRUCTIONS TO ADD CUSTOM MACROs (PART 2):                                  //
		macroOC(_LINES2, time2, lbl2, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //  2.1) Find line 364 under "CUSTOM MACROS ON CHART PLOT" title.                //
	if show3																							  //  2.2) Copy it to the following line, remove '//' and replace 'YourMacroName'  //
		macroOC(_LINES3, time3, lbl3, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //       with what you used above in step (1.2).                                 //
	if show4																							  //  2.3) Make sure the beginning of the line is aligned with all the ones above; //
		macroOC(_LINES4, time4, lbl4, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //       To do that press 'Tab' once, or add spaces until they match.            //
	if show5																							  //                                                                               //
		macroOC(_LINES5, time5, lbl5, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       ///\/////////////////////////.   CONT'D BELOW   .///////////////////////////////\//
	if show6
		macroOC(_LINES6, time6, lbl6, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       
	if show7
		macroOC(_LINES7, time7, lbl7, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       
	if show8
		macroOC(_LINES8, time8, lbl8, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       
	if show9
		macroOC(_LINES9, time9, lbl9, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       
	if show10
		macroOC(_LINES10, time10, lbl10, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show11
		macroOC(_LINES11, time11, lbl11, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show12
		macroOC(_LINES12, time12, lbl12, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show13
		macroOC(_LINES13, time13, lbl13, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show14
		macroOC(_LINES14, time14, lbl14, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show15
		macroOC(_LINES15, time15, lbl15, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show16
		macroOC(_LINES16, time16, lbl16, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show17
		macroOC(_LINES17, time17, lbl17, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show18
		macroOC(_LINES18, time18, lbl18, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show19
		macroOC(_LINES19, time19, lbl19, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show20
		macroOC(_LINES20, time20, lbl20, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show21
		macroOC(_LINES21, time21, lbl21, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show22
		macroOC(_LINES22, time22, lbl22, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show23
		macroOC(_LINES23, time23, lbl23, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if show24
		macroOC(_LINES24, time24, lbl24, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')
	if showPM1
		macroOC(_LINESPM1, timePM1, lblPM1, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')

	// CUSTOM MACROS ON CHART PLOT
	// macroOC(_lines_YourMacroName, _timeYourMacroName, _lblYourMacroName, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto', '')


else
	if show1
		macroNP(_BOXES1, time1, lbl1, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //\//////////////////////////.      \/\/\/      .//////////////////////////////\///
	if show2																							  //                                                                               //
		macroNP(_BOXES2, time2, lbl2, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //  2.4) Find line 420 under "CUSTOM MACROS NEW PANE PLOT" title.                //														          
	if show3																							  //  2.5) Copy it to the following line, remove '//' and replace 'YourMacroName'  //
		macroNP(_BOXES3, time3, lbl3, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //       with what you used above in step (1.2).                                 //
	if show4																							  //  2.6) Make sure the beginning of the line is aligned with all the ones above; //
		macroNP(_BOXES4, time4, lbl4, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       //       To do that press 'Tab' once, or add spaces until they match.            //
	if show5																							  //                                                                               //
		macroNP(_BOXES5, time5, lbl5, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       ///\///////////////////////.    LAST STEP BELOW   ./////////////////////////////\//
	if show6
		macroNP(_BOXES6, time6, lbl6, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')       
	if show7
		macroNP(_BOXES7, time7, lbl7, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto') 	  
	if show8
		macroNP(_BOXES8, time8, lbl8, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show9
		macroNP(_BOXES9, time9, lbl9, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show10
		macroNP(_BOXES10, time10, lbl10, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show11
		macroNP(_BOXES11, time11, lbl11, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show12
		macroNP(_BOXES12, time12, lbl12, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show13
		macroNP(_BOXES13, time13, lbl13, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show14
		macroNP(_BOXES14, time14, lbl14, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show15
		macroNP(_BOXES15, time15, lbl15, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show16
		macroNP(_BOXES16, time16, lbl16, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show17
		macroNP(_BOXES17, time17, lbl17, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show18
		macroNP(_BOXES18, time18, lbl18, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show19
		macroNP(_BOXES19, time19, lbl19, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show20
		macroNP(_BOXES20, time20, lbl20, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show21
		macroNP(_BOXES21, time21, lbl21, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show22
		macroNP(_BOXES22, time22, lbl22, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show23
		macroNP(_BOXES23, time23, lbl23, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if show24
		macroNP(_BOXES24, time24, lbl24, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 
	if showPM1
		macroNP(_BOXESPM1, timePM1, lblPM1, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto')																										 

	// CUSTOM MACROS NEW PANE PLOT
	// macroNP(_boxesYourMacroName, _timeYourMacroName, _lblYourMacroName, dayofweek(time)==dayofweek.friday and syminfo.type!='crypto', '')
//#endregion


//#region[MEMORY CLEAN UP]
if show1
	_LINES1.memoryCleanLine()
if show2          
	_LINES2.memoryCleanLine()
if show3                    		//\//////////////////////////.      \/\/\/      .//////////////////////////////\///        
	_LINES3.memoryCleanLine()		//                                                                               //        
if show4                    		//  2.4) Find line 477 under "CUSTOM MACROS LINE CLEAN UP" title.                //
	_LINES4.memoryCleanLine()		//  2.5) Copy it to the following line, remove '//' and replace 'YourMacroName'  //
if show5                    		//       with what you used above in step (1.2).                                 //
	_LINES5.memoryCleanLine()       //                                                                               //
if show6                     		///\/////////////////////.    YOU ARE DONE! GLGT    .///////////////////////////\//
	_LINES6.memoryCleanLine()
if show7                    
	_LINES7.memoryCleanLine()
if show8				    
	_LINES8.memoryCleanLine()
if show9				    
	_LINES9.memoryCleanLine()
if show10
	_LINES10.memoryCleanLine()
if show11
	_LINES11.memoryCleanLine()
if show12
	_LINES12.memoryCleanLine()
if show13
	_LINES13.memoryCleanLine()
if show14
	_LINES14.memoryCleanLine()
if show15
	_LINES15.memoryCleanLine()
if show16
	_LINES16.memoryCleanLine()
if show17
	_LINES17.memoryCleanLine()
if show18
	_LINES18.memoryCleanLine()
if show19
	_LINES19.memoryCleanLine()
if show20
	_LINES20.memoryCleanLine()
if show21
	_LINES21.memoryCleanLine()
if show22
	_LINES22.memoryCleanLine()
if show23
	_LINES23.memoryCleanLine()
if show24
	_LINES24.memoryCleanLine()
if showPM1
	_LINESPM1.memoryCleanLine()

// CUSTOM MACROS LINE CLEAN UP
//_lines_YourMacroName.memoryCleanLine()


EXT.memoryCleanLine()
LBL.memoryCleanLabel()
//#endregion

//------------------------------------------macros end---------------------------------------------------


// Water mark -----------------

//text inputs
title = input.string('TRADER PK', 'Tittle', group='text')
subtitle = input.string('HTF Bias| TIME  |  LQ  |  BB  |  FVG  | EXECUTION', 'Subtitle', group='text')
//symbol info
symInfoCheck = input.bool(title='Show Symbol Info', defval=true, group='watermark position')
symInfo = syminfo.ticker + ' | ' + timeframe.period + (timeframe.isminutes ? 'M' : na)
date = str.tostring(dayofmonth(time_close)) + '/' + str.tostring(month(time_close)) + '/' + str.tostring(year(time_close))
//text positioning
textVPosition = input.string('top', 'Vertical Position', options=['top', 'middle', 'bottom'], group='watermark position')
textHPosition = input.string('center', 'Horizontal Position', options=['left', 'center', 'right'], group='watermark position')
//symbol info positioning
symVPosition = input.string('bottom', 'Vertical Position', options=['top', 'middle', 'bottom'], group='symbol position')
symHPosition = input.string('center', 'Horizontal Position', options=['left', 'center', 'right'], group='symbol position')
//cell size
width = input.int(0, 'Width', minval=0, maxval=100, tooltip='The width of the cell as a % of the indicator\'s visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.', group='cell size')
height = input.int(0, 'Height', minval=0, maxval=100, tooltip='The height of the cell as a % of the indicator\'s visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.', group='cell size')
//title settings
c_title = input.color(color.new(#b2b5be, 0), 'Title Color', group='title settings')
s_title = input.string('large', 'Title Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='title settings')
a_title = input.string('center', 'Title Alignment', options=['center', 'left', 'right'], group='title settings')
//subtitle settings
c_subtitle = input.color(color.new(#b2b5be, 30), 'Subitle Color', group='subtitle settings')
s_subtitle = input.string('normal', 'Subtitle Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='subtitle settings')
a_subtitle = input.string('center', 'Subtitle Alignment', options=['center', 'left', 'right'], group='subtitle settings')

//symbol settings
c_symInfo = input.color(color.new(#b2b5be, 30), 'Subitle Color', group='symbol settings')
s_symInfo = input.string('normal', 'Subtitle Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='symbol settings')
a_symInfo = input.string('center', 'Subtitle Alignment', options=['center', 'left', 'right'], group='symbol settings')
c_bg = input.color(color.new(#b2b5be, 100), 'Background', group='background')


//text watermark creation
textWatermark = table.new(textVPosition + '_' + textHPosition, 1, 3)
table.cell(textWatermark, 0, 0, title, width, height, c_title, a_title, text_size=s_title, bgcolor=c_bg)
table.cell(textWatermark, 0, 1, subtitle, width, height, c_subtitle, a_subtitle, text_size=s_subtitle, bgcolor=c_bg)
//symbol info watermark creation
symWatermark = table.new(symVPosition + '_' + symHPosition, 5, 5)
if symInfoCheck == true
    table.cell(symWatermark, 0, 1, symInfo, width, height, c_symInfo, a_symInfo, text_size=s_symInfo, bgcolor=c_bg)
    table.cell(symWatermark, 0, 0, date, width, height, c_symInfo, a_symInfo, text_size=s_symInfo, bgcolor=c_bg)
//text watermark End -------------------------------------------------------------------------------



//multi time frame FVG ---------------------------------------------------------------------------
//+------------------------------------------------------------------------------------------------------------+//
//+--- Types                                                                                                ---+//
//+------------------------------------------------------------------------------------------------------------+//
type Settings 
    bool    CE_show
    string  CE_style
    color   CE_color
    bool    Border_show
    bool    mitigated_show
    string  mitigated_type
    color   mitigated_color_bull
    color   mitigated_color_bear
    bool    ltf_hide
    bool    label_show
    color   label_color
    color   label_bgcolor
    string  label_size
    int     padding
    int     buffer

type Imbalance_Settings
    bool    show
    string  htf
    color   color_bull
    color   color_bear
    int     max_count

type Imbalance
    int     open_time
    int     close_time
    float   open
    float   middle
    float   close
    bool    mitigated
    int     mitigated_time
    line    line_middle
    label   lbl
    box     box

type ImbalanceStructure
    Imbalance[]         imbalance
    Imbalance_Settings  settings

type Helper
    string name         = "Helper"

//+------------------------------------------------------------------------------------------------------------+//
//+--- Settings                                                                                             ---+//
//+------------------------------------------------------------------------------------------------------------+//
Settings_Group                      = "Global Settings"

Settings settings                   = Settings.new()
Imbalance_Settings HTF_1_Settings   = Imbalance_Settings.new()
Imbalance_Settings HTF_2_Settings   = Imbalance_Settings.new()
Imbalance_Settings HTF_3_Settings   = Imbalance_Settings.new()
Imbalance_Settings HTF_4_Settings   = Imbalance_Settings.new()
Imbalance_Settings HTF_5_Settings   = Imbalance_Settings.new()
Imbalance_Settings HTF_6_Settings   = Imbalance_Settings.new()

string tooltip1 = "HTF FVG Settings:\n\tShow/Hide timeframe\n\tTimeframe to display\n\tBullish FVG Color\n\tBearish FVG Color\n\tMaximum number of FVGs to display"
string tooltip2 = "Mitigated FVG Settings:\n\tShow/Hide mitigated (Applies to all).\n\tBullish FVG Color\n\tBearish FVG Color\n\tWhen to mark it as mitigated (Based on HTF timeframe, not current timeframe)"

HTF_1_Settings.show         := input.bool(false, "", inline="htf1")
htf_1                        = input.timeframe("5", "", inline="htf1")
HTF_1_Settings.htf          := htf_1
HTF_1_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf1")
HTF_1_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf1")
HTF_1_Settings.max_count    := input.int(20, "", inline="htf1", tooltip = tooltip1)

HTF_2_Settings.show         := input.bool(false, "", inline="htf2")
htf_2                        = input.timeframe("15", "", inline="htf2")
HTF_2_Settings.htf          := htf_2
HTF_2_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf2")
HTF_2_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf2")
HTF_2_Settings.max_count    := input.int(20, "", inline="htf2", tooltip = tooltip1)

HTF_3_Settings.show         := input.bool(true, "", inline="htf3")
htf_3                        = input.timeframe("60", "", inline="htf3")
HTF_3_Settings.htf          := htf_3
HTF_3_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf3")
HTF_3_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf3")
HTF_3_Settings.max_count    := input.int(20, "", inline="htf3", tooltip = tooltip1)

HTF_4_Settings.show         := input.bool(true, "", inline="htf4")
htf_4                        = input.timeframe("240", "", inline="htf4")
HTF_4_Settings.htf          := htf_4
HTF_4_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf4")
HTF_4_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf4")
HTF_4_Settings.max_count    := input.int(10, "", inline="htf4", tooltip = tooltip1)

HTF_5_Settings.show         := input.bool(true, "", inline="htf5")
htf_5                        = input.timeframe("1D", "", inline="htf5")
HTF_5_Settings.htf          := htf_5
HTF_5_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf5")
HTF_5_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf5")
HTF_5_Settings.max_count    := input.int(10, "", inline="htf5", tooltip = tooltip1)

HTF_6_Settings.show         := input.bool(true, "", inline="htf6")
htf_6                        = input.timeframe("1W", "", inline="htf6")
HTF_6_Settings.htf          := htf_6
HTF_6_Settings.color_bull   := input.color(color.new(color.green,90), "", inline="htf6")
HTF_6_Settings.color_bear   := input.color(color.new(color.blue,90), "", inline="htf6")
HTF_6_Settings.max_count    := input.int(2, "", inline="htf6", tooltip = tooltip1)

settings.ltf_hide               := input.bool(true, "Hide Lower Timeframes")
settings.Border_show            := input.bool(true, "Show Border", group=Settings_Group, inline="4")
settings.mitigated_show         := input.bool(false, "Show Mitigated", group=Settings_Group, inline="2")
settings.mitigated_color_bull   := input.color(color.new(color.gray,95), "", group=Settings_Group, inline="2")
settings.mitigated_color_bear   := input.color(color.new(color.gray,95), "", group=Settings_Group, inline="2")
settings.mitigated_type         := input.string('Wick filled', 'when', options = ['None', 'Wick filled', 'Body filled', 'Wick filled half', 'Body filled half'], group=Settings_Group, inline="2", tooltip=tooltip2)
settings.CE_show                := input.bool(true, "Show C.E.     ", group=Settings_Group, inline="3")
settings.CE_color               := input.color(color.new(color.black,60), "", group=Settings_Group, inline="3")
settings.CE_style               := input.string('····', '     ', options = ['⎯⎯⎯', '----', '····'], group=Settings_Group, inline="3")
settings.label_show             := input.bool(true, "Show Label   ", inline="label")
settings.label_color            := input.color(color.new(color.black, 10), "", inline='label')
settings.label_bgcolor          := input.color(color.new(color.white, 100), "", inline='label')
settings.label_size             := input.string(size.small, "", [size.tiny, size.small, size.normal, size.large, size.huge], inline="label")
settings.padding                := input.int(4, "Distance from current candle", minval=0)
settings.buffer                 := input.int(6, "Spacing between timeframes", minval=0)

//+------------------------------------------------------------------------------------------------------------+//
//+--- Variables                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
color color_transparent             = #ffffff00

Helper helper                       = Helper.new()

var ImbalanceStructure FVG_1        = ImbalanceStructure.new()
var ImbalanceStructure FVG_2        = ImbalanceStructure.new()
var ImbalanceStructure FVG_3        = ImbalanceStructure.new()
var ImbalanceStructure FVG_4        = ImbalanceStructure.new()
var ImbalanceStructure FVG_5        = ImbalanceStructure.new()
var ImbalanceStructure FVG_6        = ImbalanceStructure.new()

var Imbalance[] FVGs_1              = array.new<Imbalance>()
var Imbalance[] FVGs_2              = array.new<Imbalance>()
var Imbalance[] FVGs_3              = array.new<Imbalance>()
var Imbalance[] FVGs_4              = array.new<Imbalance>()
var Imbalance[] FVGs_5              = array.new<Imbalance>()
var Imbalance[] FVGs_6              = array.new<Imbalance>()

FVG_1.imbalance                     := FVGs_1
FVG_1.settings                      := HTF_1_Settings
FVG_2.imbalance                     := FVGs_2
FVG_2.settings                      := HTF_2_Settings
FVG_3.imbalance                     := FVGs_3
FVG_3.settings                      := HTF_3_Settings
FVG_4.imbalance                     := FVGs_4
FVG_4.settings                      := HTF_4_Settings
FVG_5.imbalance                     := FVGs_5
FVG_5.settings                      := HTF_5_Settings
FVG_6.imbalance                     := FVGs_6
FVG_6.settings                      := HTF_6_Settings

//Used internally for padding
var int TF_1        = 0
var int TF_2        = 0
var int TF_3        = 0
var int TF_4        = 0
var int TF_5        = 0
var int TF_6        = 0

var float daily     = 0
var float monthly   = 0
//+------------------------------------------------------------------------------------------------------------+//
//+--- Methods                                                                                              ---+//
//+------------------------------------------------------------------------------------------------------------+//
method LineStyle(Helper helper, string style) =>
    helper.name := style

    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid
    
    out

method Gethtftext(Helper helper, string htf) =>
    helper.name := htf

    formatted = htf
    seconds = timeframe.in_seconds(htf)

    if seconds < 60
        formatted := str.tostring(seconds) + "s"
    else if (seconds / 60) < 60
        formatted := str.tostring((seconds/60)) + "m"
    else if (seconds/60/60) < 24
        formatted := str.tostring((seconds/60/60)) + "H"
    
    formatted

method Validtimeframe(Helper helper, tf) =>
    helper.name := tf
    n1 = timeframe.in_seconds()
    n2 = timeframe.in_seconds(tf)

    n1 < n2

method ProximityRange(Helper helper, tf) =>
    helper.name := tf
    float range_high    = 0
    float range_low   = 0
    if timeframe.isseconds or timeframe.isminutes
        range_high := close + daily
        range_low  := close - daily
    if timeframe.isdaily
        range_high := close + monthly*3
        range_low  := close - monthly*3
    if timeframe.isweekly
        range_high := close + monthly*12
        range_low  := close - monthly*12

    [range_low, range_high]

//+------------------------------------------------------------------------------------------------------------+//
//+--- Imbalances Methods                                                                                   ---+//
//+------------------------------------------------------------------------------------------------------------+//
// AddZone is used to display and manage imbalance related boxes
method AddZone(ImbalanceStructure IS, Imbalance imb, int step) =>
    bool visible = true
    if IS.settings.show
        int buffer = time+((time-time[1])*(settings.padding+1+(settings.buffer*(step-1))))

        if na(imb.box)
            imb.box := box.new(imb.open_time, imb.open, buffer, imb.close, settings.Border_show ? imb.open < imb.close ? color.new(IS.settings.color_bull, color.t(IS.settings.color_bull)/ 3) : color.new(IS.settings.color_bear, color.t(IS.settings.color_bear)/ 3) : color_transparent, settings.Border_show ? 1 : 0, bgcolor = imb.open < imb.close ? IS.settings.color_bull : IS.settings.color_bear, xloc=xloc.bar_time)
            if settings.label_show
                imb.lbl := label.new(buffer, imb.middle, text=helper.Gethtftext(IS.settings.htf), xloc=xloc.bar_time, textcolor=settings.label_color, style=label.style_label_left, color=settings.label_bgcolor, size = settings.label_size)
            if settings.CE_show
                imb.line_middle := line.new(imb.open_time, imb.middle, buffer, imb.middle, xloc=xloc.bar_time, style=helper.LineStyle(settings.CE_style), color=settings.CE_color)
        else
            box.set_right(imb.box, imb.mitigated ? imb.mitigated_time : buffer)
            box.set_bgcolor(imb.box, imb.open < imb.close ? imb.mitigated ? settings.mitigated_color_bull : IS.settings.color_bull : imb.mitigated ? settings.mitigated_color_bear : IS.settings.color_bear)
            box.set_border_color(imb.box, settings.Border_show ? imb.open < imb.close ? color.new(settings.mitigated_color_bull, color.t(settings.mitigated_color_bull)/ 3) : color.new(settings.mitigated_color_bear, color.t(settings.mitigated_color_bear)/ 3) : color_transparent)
            label.set_x(imb.lbl, imb.mitigated ? imb.mitigated_time : buffer)
            //label.delete(imb.lbl)
            if settings.CE_show
                line.set_x2(imb.line_middle, imb.mitigated ? imb.mitigated_time : buffer)
        if imb.mitigated and not settings.mitigated_show
            if not na(imb.box)
                box.delete(imb.box)
                line.delete(imb.line_middle)
                label.delete(imb.lbl)
                visible := false
    visible

// AddImbalance adds a newly discovered imbalance. this applies for both FVG and Volume Imbalance
method AddImbalance(ImbalanceStructure IS, float o, float c, int o_time) =>
    Imbalance imb = Imbalance.new()
    imb.open_time           := o_time
    imb.open                := o
    imb.middle              := (o+c)/2
    imb.close               := c

    IS.imbalance.unshift(imb)
    //IS.AddZone(imb)

    if IS.imbalance.size() > 100 //IS.settings.max_count
        temp = IS.imbalance.pop()
        if not na(temp.box)
            box.delete(temp.box)
            line.delete(temp.line_middle)
            label.delete(temp.lbl)
    IS

// CheckMitigated checks if the imbalance has been mitigated based on the settings
method CheckMitigated(ImbalanceStructure IS, o, h, l, c) =>
    if IS.imbalance.size() > 0
        for i = IS.imbalance.size() - 1 to 0
            imb = IS.imbalance.get(i)

            if not imb.mitigated
                switch settings.mitigated_type
                    "None" =>
                        imb.mitigated       := false
                    'Wick filled' =>
                        imb.mitigated       := imb.open <= imb.close ? low <= imb.open : high >= imb.open
                    'Body filled' =>
                        imb.mitigated       := imb.open < imb.close ? math.min(o, c) <= imb.open : math.max(o, c) >= imb.open
                    'Wick filled half' =>
                        imb.mitigated       := imb.open <= imb.close ? low <= imb.middle : high >= imb.middle
                    'Body filled half' =>
                        imb.mitigated       := imb.open <= imb.close ? math.min(o, c) <= imb.middle : math.max(o, c) >= imb.middle
                if imb.mitigated
                    if not settings.mitigated_show
                        if not na(imb.box)
                            box.delete(imb.box)
                            line.delete(imb.line_middle)
                            label.delete(imb.lbl)
                        IS.imbalance.remove(i)
                    else
                        imb.mitigated_time  := time
    IS

method AdjustMargins(ImbalanceStructure IS, int step) =>
    int count = 0
    if IS.imbalance.size() > 0
        int buffer = time+((time-time[1])*(settings.padding+1+(settings.buffer*(step-1))))
        
        [rl, rh] = helper.ProximityRange(IS.settings.htf)

        for i = 0 to IS.imbalance.size() - 1
            imb = IS.imbalance.get(i)
            if ((math.max(imb.open, imb.close) > rl) and (math.min(imb.open, imb.close) < rh)) and count < IS.settings.max_count
                if IS.AddZone(imb, step)
                    count := count+1
            else
                if not na(imb.box)
                    box.delete(imb.box)
                    label.delete(imb.lbl)
                    line.delete((imb.line_middle))
    IS
// FindImbalance looks for imbalances and, if found, adds it to the list
method FindImbalance(ImbalanceStructure IS, o, h, l, c, t, o1, h1, l1, c1, t1, o2, h2, l2, c2, t2) =>
    if IS.settings.show and (h < l2 or l > h2) 
        o = h < l2 ? l2 : h2
        c = h < l2 ? h : l
        if IS.imbalance.size() == 0 
            IS.AddImbalance(o, c, t2)
        else
            if IS.imbalance.first().open_time < t2
                IS.AddImbalance(o, c, t2)
    IS

method Process(ImbalanceStructure IS, float o, float h, float l, float c, int t, float o1, float h1, float l1, float c1, int t1, float o2, float h2, float l2, float c2, int t2) =>
    var int visible = 0
    if IS.settings.show
        if not settings.ltf_hide or (settings.ltf_hide and helper.Validtimeframe(IS.settings.htf))
            if IS.settings.show
                IS.FindImbalance(o, h, l, c, t, o1, h1, l1, c1, t1, o2, h2, l2, c2, t2)
                visible := 1
        IS.CheckMitigated(o, h, l, c)
    visible
//+------------------------------------------------------------------------------------------------------------+//
//+--- Main call to start the process                                                                       ---+//
//+------------------------------------------------------------------------------------------------------------+//

daily                                   := request.security(syminfo.tickerid, "1D", ta.atr(14))
monthly                                 := request.security(syminfo.tickerid, "1M", ta.atr(14))

[o_1, h_1, l_1, c_1, t_1]               = request.security(syminfo.tickerid, htf_1, [open[1], high[1], low[1], close[1], time[1]])
[o1_1, h1_1, l1_1, c1_1, t1_1]          = request.security(syminfo.tickerid, htf_1, [open[2], high[2], low[2], close[2], time[2]])
[o2_1, h2_1, l2_1, c2_1, t2_1]          = request.security(syminfo.tickerid, htf_1, [open[3], high[3], low[3], close[3], time[3]])
TF_1 := FVG_1.Process(o_1, h_1, l_1, c_1, t_1, o1_1, h1_1, l1_1, c1_1, t1_1, o2_1, h2_1, l2_1, c2_1, t2_1)
FVG_1.AdjustMargins(TF_1)

[o_2, h_2, l_2, c_2, t_2]               = request.security(syminfo.tickerid, htf_2, [open[1], high[1], low[1], close[1], time[1]])
[o1_2, h1_2, l1_2, c1_2, t1_2]          = request.security(syminfo.tickerid, htf_2, [open[2], high[2], low[2], close[2], time[2]])
[o2_2, h2_2, l2_2, c2_2, t2_2]          = request.security(syminfo.tickerid, htf_2, [open[3], high[3], low[3], close[3], time[3]])
TF_2 := TF_1 + FVG_2.Process(o_2, h_2, l_2, c_2, t_2, o1_2, h1_2, l1_2, c1_2, t1_2, o2_2, h2_2, l2_2, c2_2, t2_2)
FVG_2.AdjustMargins(TF_2)

[o_3, h_3, l_3, c_3, t_3]               = request.security(syminfo.tickerid, htf_3, [open[1], high[1], low[1], close[1], time[1]])
[o1_3, h1_3, l1_3, c1_3, t1_3]          = request.security(syminfo.tickerid, htf_3, [open[2], high[2], low[2], close[2], time[2]])
[o2_3, h2_3, l2_3, c2_3, t2_3]          = request.security(syminfo.tickerid, htf_3, [open[3], high[3], low[3], close[3], time[3]])
TF_3 := TF_2 + FVG_3.Process(o_3, h_3, l_3, c_3, t_3, o1_3, h1_3, l1_3, c1_3, t1_3, o2_3, h2_3, l2_3, c2_3, t2_3)
FVG_3.AdjustMargins(TF_3)

[o_4, h_4, l_4, c_4, t_4]               = request.security(syminfo.tickerid, htf_4, [open[1], high[1], low[1], close[1], time[1]])
[o1_4, h1_4, l1_4, c1_4, t1_4]          = request.security(syminfo.tickerid, htf_4, [open[2], high[2], low[2], close[2], time[2]])
[o2_4, h2_4, l2_4, c2_4, t2_4]          = request.security(syminfo.tickerid, htf_4, [open[3], high[3], low[3], close[3], time[3]])
TF_4 := TF_3 + FVG_4.Process(o_4, h_4, l_4, c_4, t_4, o1_4, h1_4, l1_4, c1_4, t1_4, o2_4, h2_4, l2_4, c2_4, t2_4)
FVG_4.AdjustMargins(TF_4)

[o_5, h_5, l_5, c_5, t_5]               = request.security(syminfo.tickerid, htf_5, [open[1], high[1], low[1], close[1], time[1]])
[o1_5, h1_5, l1_5, c1_5, t1_5]          = request.security(syminfo.tickerid, htf_5, [open[2], high[2], low[2], close[2], time[2]])
[o2_5, h2_5, l2_5, c2_5, t2_5]          = request.security(syminfo.tickerid, htf_5, [open[3], high[3], low[3], close[3], time[3]])
TF_5 := TF_4 + FVG_5.Process(o_5, h_5, l_5, c_5, t_5, o1_5, h1_5, l1_5, c1_5, t1_5, o2_5, h2_5, l2_5, c2_5, t2_5)
FVG_5.AdjustMargins(TF_5)

[o_6, h_6, l_6, c_6, t_6]               = request.security(syminfo.tickerid, htf_6, [open[1], high[1], low[1], close[1], time[1]])
[o1_6, h1_6, l1_6, c1_6, t1_6]          = request.security(syminfo.tickerid, htf_6, [open[2], high[2], low[2], close[2], time[2]])
[o2_6, h2_6, l2_6, c2_6, t2_6]          = request.security(syminfo.tickerid, htf_6, [open[3], high[3], low[3], close[3], time[3]])
TF_6 := TF_5 + FVG_6.Process(o_6, h_6, l_6, c_6, t_6, o1_6, h1_6, l1_6, c1_6, t1_6, o2_6, h2_6, l2_6, c2_6, t2_6)
FVG_6.AdjustMargins(TF_6)

//-------------------------2nd file ------------------------------------------------

//35 works
displayStyle = input.string(defval='Standard', title='Display Style', options=['Standard', 'Right Anchored'], inline='Display')
mergebool = input.bool(defval=true, title='Merge Levels?', inline='Display')
distanceright = input.int(defval=30, title='Distance', minval=5, maxval=500, inline='Dist')
radistance = input.int(defval=250, title='Anchor Distance', minval=5, maxval=500, inline='Dist')
labelsize = input.string(defval='Medium', title='Text Size', options=['Small', 'Medium', 'Large'])
linesize = input.string(defval='Small', title='Line Width', options=['Small', 'Medium', 'Large'], inline='Line')
linestyle = input.string(defval='Solid', title='Line Style', options=['Solid', 'Dashed', 'Dotted'], inline='Line')



GlobalTextType = input.bool(defval=false, title='Global Text ShortHand', tooltip='Enable for shorthand text on all text')
var globalcoloring = input.bool(defval=false, title='Global Coloring', tooltip='Enable for all color controls via one color', inline='GC')
GlobalColor = input.color(title='', defval=color.white, inline='GC')
//var show_tails = input(defval = false, title = "Always Show", type = input.bool)


[daily_time, daily_open] = request.security(syminfo.tickerid, 'D', [time, open], lookahead=barmerge.lookahead_on)
[dailyh_time, dailyh_open] = request.security(syminfo.tickerid, 'D', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[dailyl_time, dailyl_open] = request.security(syminfo.tickerid, 'D', [time[1], low[1]], lookahead=barmerge.lookahead_on)

cdailyh_open = request.security(syminfo.tickerid, 'D', high, lookahead=barmerge.lookahead_on)
cdailyl_open = request.security(syminfo.tickerid, 'D', low, lookahead=barmerge.lookahead_on)
var monday_time = time
var monday_high = high
var monday_low = low

[weekly_time, weekly_open] = request.security(syminfo.tickerid, 'W', [time, open], lookahead=barmerge.lookahead_on)
[weeklyh_time, weeklyh_open] = request.security(syminfo.tickerid, 'W', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[weeklyl_time, weeklyl_open] = request.security(syminfo.tickerid, 'W', [time[1], low[1]], lookahead=barmerge.lookahead_on)


[monthly_time, monthly_open] = request.security(syminfo.tickerid, 'M', [time, open], lookahead=barmerge.lookahead_on)
[monthlyh_time, monthlyh_open] = request.security(syminfo.tickerid, 'M', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[monthlyl_time, monthlyl_open] = request.security(syminfo.tickerid, 'M', [time[1], low[1]], lookahead=barmerge.lookahead_on)


[quarterly_time, quarterly_open] = request.security(syminfo.tickerid, '3M', [time, open], lookahead=barmerge.lookahead_on)
[quarterlyh_time, quarterlyh_open] = request.security(syminfo.tickerid, '3M', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[quarterlyl_time, quarterlyl_open] = request.security(syminfo.tickerid, '3M', [time[1], low[1]], lookahead=barmerge.lookahead_on)


[yearly_time, yearly_open] = request.security(syminfo.tickerid, '12M', [time, open], lookahead=barmerge.lookahead_on)
[yearlyh_time, yearlyh_open] = request.security(syminfo.tickerid, '12M', [time, high], lookahead=barmerge.lookahead_on)
[yearlyl_time, yearlyl_open] = request.security(syminfo.tickerid, '12M', [time, low], lookahead=barmerge.lookahead_on)


[intra_time, intra_open] = request.security(syminfo.tickerid, '240', [time, open], lookahead=barmerge.lookahead_on)
[intrah_time, intrah_open] = request.security(syminfo.tickerid, '240', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[intral_time, intral_open] = request.security(syminfo.tickerid, '240', [time[1], low[1]], lookahead=barmerge.lookahead_on)

//------------------------------ Inputs -------------------------------

var is_intra_enabled = input.bool(defval=false, title='Open', group='4H', inline='4H')
var is_intrarange_enabled = input.bool(defval=false, title='Prev H/L', group='4H', inline='4H')
var is_intram_enabled = input.bool(defval=false, title='Prev Mid', group='4H', inline='4H')
IntraTextType = input.bool(defval=false, title='ShortHand', group='4H', inline='4Hsh')

var is_daily_enabled = input.bool(defval=true, title='Open', group='Daily', inline='Daily')
var is_dailyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Daily', inline='Daily')
var is_dailym_enabled = input.bool(defval=true, title='Prev Mid', group='Daily', inline='Daily')
DailyTextType = input.bool(defval=false, title='ShortHand', group='Daily', inline='Dailysh')

var is_monday_enabled = input.bool(defval=false, title='Range', group='Monday Range', inline='Monday')
var is_monday_mid = input.bool(defval=false, title='Mid', group='Monday Range', inline='Monday')
var untested_monday = false
MondayTextType = input.bool(defval=false, title='ShortHand', group='Monday Range', inline='Mondaysh')

var is_weekly_enabled = input.bool(defval=true, title='Open', group='Weekly', inline='Weekly')
var is_weeklyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Weekly', inline='Weekly')
var is_weekly_mid = input.bool(defval=true, title='Prev Mid', group='Weekly', inline='Weekly')
WeeklyTextType = input.bool(defval=false, title='ShortHand', group='Weekly', inline='Weeklysh')

var is_monthly_enabled = input.bool(defval=false, title='Open', group='Monthly', inline='Monthly')
var is_monthlyrange_enabled = input.bool(defval=false, title='Prev H/L', group='Monthly', inline='Monthly')
var is_monthly_mid = input.bool(defval=false, title='Prev Mid', group='Monthly', inline='Monthly')
MonthlyTextType = input.bool(defval=false, title='ShortHand', group='Monthly', inline='Monthlysh')

var is_quarterly_enabled = input.bool(defval=false, title='Open', group='Quarterly', inline='Quarterly')
var is_quarterlyrange_enabled = input.bool(defval=false, title='Prev H/L', group='Quarterly', inline='Quarterly')
var is_quarterly_mid = input.bool(defval=false, title='Prev Mid', group='Quarterly', inline='Quarterly')
QuarterlyTextType = input.bool(defval=false, title='ShortHand', group='Quarterly', inline='Quarterlysh')

var is_yearly_enabled = input.bool(defval=false, title='Open', group='Yearly', inline='Yearly')
var is_yearlyrange_enabled = input.bool(defval=false, title='Current H/L', group='Yearly', inline='Yearly')
var is_yearly_mid = input.bool(defval=false, title='Mid', group='Yearly', inline='Yearly')
YearlyTextType = input.bool(defval=false, title='ShortHand', group='Yearly', inline='Yearlysh')

var is_londonrange_enabled = input.bool(defval=false, title='London Range', group='FX Sessions', inline='FX')
var is_usrange_enabled = input.bool(defval=false, title='New York Range', group='FX Sessions', inline='FX')
var is_asiarange_enabled = input.bool(defval=false, title='Asia Range', group='FX Sessions', inline='FX')
SessionTextType = input.bool(defval=false, title='ShortHand', group='FX Sessions', inline='FXColor')

Londont = input.session("0800-1600", "London Session")
USt = input.session("1400-2100", "New York Session")
Asiat = input.session("0000-0900", "Tokyo Session")

DailyColor = input.color(title='', defval=#08bcd4, group='Daily', inline='Dailysh')
MondayColor = input.color(title='', defval=color.white, group='Monday Range', inline='Mondaysh')
WeeklyColor = input.color(title='', defval=#fffcbc, group='Weekly', inline='Weeklysh')
MonthlyColor = input.color(title='', defval=#08d48c, group='Monthly', inline='Monthlysh')
YearlyColor = input.color(title='', defval=color.red, group='Yearly', inline='Yearlysh')
quarterlyColor = input.color(title='', defval=color.red, group='Quarterly', inline='Quarterlysh')
IntraColor = input.color(title='', defval=color.orange, group='4H', inline='4Hsh')
LondonColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
USColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
AsiaColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
var pdhtext = GlobalTextType or DailyTextType ? 'PDH' : 'Prev Day High'
var pdltext = GlobalTextType or DailyTextType ? 'PDL' : 'Prev Day Low'
var dotext = GlobalTextType or DailyTextType ? 'DO' : 'Daily Open'
var pdmtext = GlobalTextType or DailyTextType ? 'PDM' : 'Prev Day Mid'

var pwhtext = GlobalTextType or WeeklyTextType ? 'PWH' : 'Prev Week High'
var pwltext = GlobalTextType or WeeklyTextType ? 'PWL' : 'Prev Week Low'
var wotext = GlobalTextType or WeeklyTextType ? 'WO' : 'Weekly Open'
var pwmtext = GlobalTextType or WeeklyTextType ? 'PWM' : 'Prev Week Mid'

var pmhtext = GlobalTextType or MonthlyTextType ? 'PMH' : 'Prev Month High'
var pmltext = GlobalTextType or MonthlyTextType ? 'PML' : 'Prev Month Low'
var motext = GlobalTextType or MonthlyTextType ? 'MO' : 'Monthly Open'
var pmmtext = GlobalTextType or MonthlyTextType ? 'PMM' : 'Prev Month Mid'

var pqhtext = GlobalTextType or QuarterlyTextType ? 'PQH' : 'Prev Quarter High'
var pqltext = GlobalTextType or QuarterlyTextType ? 'PQL' : 'Prev Quarter Low'
var qotext = GlobalTextType or QuarterlyTextType ? 'QO' : 'Quarterly Open'
var pqmtext = GlobalTextType or QuarterlyTextType ? 'PQM' : 'Prev Quarter Mid'

var cyhtext = GlobalTextType or YearlyTextType ? 'CYH' : 'Current Year High'
var cyltext = GlobalTextType or YearlyTextType ? 'CYL' : 'Current Year Low'
var yotext = GlobalTextType or YearlyTextType ? 'YO' : 'Yearly Open'
var cymtext = GlobalTextType or YearlyTextType ? 'CYM' : 'Current Year Mid'

var pihtext = GlobalTextType or IntraTextType ? 'P-4H-H' : 'Prev 4H High'
var piltext = GlobalTextType or IntraTextType ? 'P-4H-L' : 'Prev 4H Low'
var iotext = GlobalTextType or IntraTextType ? '4H-O' : '4H Open'
var pimtext = GlobalTextType or IntraTextType ? 'P-4H-M' : 'Prev 4H Mid'

var pmonhtext = GlobalTextType or MondayTextType ? 'MDAY-H' : 'Monday High'
var pmonltext = GlobalTextType or MondayTextType ? 'MDAY-L' : 'Monday Low'
var pmonmtext = GlobalTextType or MondayTextType ? 'MDAY-M' : 'Monday Mid'

var lhtext = GlobalTextType or SessionTextType ? 'Lon-H' : 'London High'
var lltext = GlobalTextType or SessionTextType ? 'Lon-L' : 'London Low'
var lotext = GlobalTextType or SessionTextType ? 'Lon-O' : 'London Open'

var ushtext = GlobalTextType or SessionTextType ? 'NY-H' : 'New York High'
var usltext = GlobalTextType or SessionTextType ? 'NY-L' : 'New York Low'
var usotext = GlobalTextType or SessionTextType ? 'NY-O' : 'New York Open'

var asiahtext = GlobalTextType or SessionTextType ? 'AS-H' : 'Asia High'
var asialtext = GlobalTextType or SessionTextType ? 'AS-L' : 'Asia Low'
var asiaotext = GlobalTextType or SessionTextType ? 'AS-O' : 'Asia Open'

if globalcoloring == true
    DailyColor := GlobalColor
    MondayColor := GlobalColor
    WeeklyColor := GlobalColor
    MonthlyColor := GlobalColor
    YearlyColor := GlobalColor
    quarterlyColor := GlobalColor
    IntraColor := GlobalColor
    IntraColor

if weekly_time != weekly_time[1]
    untested_monday := false
    untested_monday

if is_monday_enabled == true and untested_monday == false
    untested_monday := true
    monday_time := daily_time
    monday_high := cdailyh_open
    monday_low := cdailyl_open
    monday_low

linewidthint = 1
if linesize == 'Small'
    linewidthint := 1
    linewidthint
if linesize == 'Medium'
    linewidthint := 2
    linewidthint
if linesize == 'Large'
    linewidthint := 3
    linewidthint

var DEFAULT_LINE_WIDTH = linewidthint
var DEFAULT_TAIL_WIDTH = linewidthint

fontsize = size.small

if labelsize == 'Small'
    fontsize := size.small
    fontsize

if labelsize == 'Medium'
    fontsize := size.normal
    fontsize

if labelsize == 'Large'
    fontsize := size.large
    fontsize

linestyles = line.style_solid
if linestyle == 'Dashed'
    linestyles := line.style_dashed
    linestyles

if linestyle == 'Dotted'
    linestyles := line.style_dotted
    linestyles

var DEFAULT_LABEL_SIZE = fontsize
var DEFAULT_LABEL_STYLE = label.style_none
var DEFAULT_EXTEND_RIGHT = distanceright

London = time(timeframe.period, Londont)
US = time(timeframe.period, USt)
Asia = time(timeframe.period, Asiat)

var clondonhigh = 0.0
var clondonlow = close
var londontime = time
var flondonhigh = 0.0
var flondonlow = 0.0
var flondonopen = 0.0

var onelondonfalse = false
if London
    if high > clondonhigh
        clondonhigh := high
        clondonhigh
    if low < clondonlow
        clondonlow := low
        clondonlow
    if onelondonfalse
        londontime := time
        flondonopen := open
        flondonopen
    flondonhigh := clondonhigh
    flondonlow := clondonlow
    onelondonfalse := false
    onelondonfalse
else
    if onelondonfalse == false
        flondonhigh := clondonhigh
        flondonlow := clondonlow
        flondonlow
    onelondonfalse := true

    clondonhigh := 0.0
    clondonlow := close
    clondonlow

//////////////////////////////////
var cushigh = 0.0
var cuslow = close
var ustime = time
var fushigh = 0.0
var fuslow = 0.0
var fusopen = 0.0

var oneusfalse = false
if US
    if high > cushigh
        cushigh := high
        cushigh
    if low < cuslow
        cuslow := low
        cuslow
    if oneusfalse
        ustime := time
        fusopen := open
        fusopen
    fushigh := cushigh
    fuslow := cuslow
    oneusfalse := false
    oneusfalse
else
    if oneusfalse == false
        fushigh := cushigh
        fuslow := cuslow
        fuslow
    oneusfalse := true

    cushigh := 0.0
    cuslow := close
    cuslow

//////////////////////////////////
var casiahigh = 0.0
var casialow = close
var asiatime = time
var fasiahigh = 0.0
var fasialow = 0.0
var fasiaopen = 0.0

var oneasiafalse = false
if Asia
    if high > casiahigh
        casiahigh := high
        casiahigh
    if low < casialow
        casialow := low
        casialow
    if oneasiafalse
        asiatime := time
        fasiaopen := open
        fasiaopen
    fasiahigh := casiahigh
    fasialow := casialow
    oneasiafalse := false
    oneasiafalse
else
    if oneasiafalse == false
        fasiahigh := casiahigh
        fasialow := casialow
        fasialow
    oneasiafalse := true

    casiahigh := 0.0
    casialow := close
    casialow

//------------------------------ Plotting ------------------------------
var pricearray = array.new_float(0)
var labelarray = array.new_label(0)
f_LevelMerge(pricearray, labelarray, currentprice, currentlabel, currentcolor) =>
    if array.includes(pricearray, currentprice)
        whichindex = array.indexof(pricearray, currentprice)
        labelhold = array.get(labelarray, whichindex)
        whichtext = label.get_text(labelhold)

        label.set_text(labelhold, label.get_text(currentlabel) + ' / ' + whichtext)
        label.set_text(currentlabel, '')
        label.set_textcolor(labelhold, currentcolor)
    else
        array.push(pricearray, currentprice)
        array.push(labelarray, currentlabel)


var can_show_daily = is_daily_enabled and timeframe.isintraday
var can_show_weekly = is_weekly_enabled and not timeframe.isweekly and not timeframe.ismonthly
var can_show_monthly = is_monthly_enabled and not timeframe.ismonthly

get_limit_right(bars) =>
    timenow + (time - time[1]) * bars

// the following code doesn't need to be processed on every candle
if barstate.islast
    is_weekly_open = dayofweek == dayofweek.monday
    is_monthly_open = dayofmonth == 1
    can_draw_daily = (is_weekly_enabled ? not is_weekly_open : true) and (is_monthly_enabled ? not is_monthly_open : true)
    can_draw_weekly = is_monthly_enabled ? not(is_monthly_open and is_weekly_open) : true
    can_draw_intra = is_intra_enabled
    can_draw_intrah = is_intrarange_enabled
    can_draw_intral = is_intrarange_enabled
    can_draw_intram = is_intram_enabled
    pricearray := array.new_float(0)
    labelarray := array.new_label(0)

    /////////////////////////////////

    if is_londonrange_enabled
        //label.new(bar_index,high)
        london_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)


        if displayStyle == 'Right Anchored'
            londontime := get_limit_right(radistance)
            londontime

        var londonh_line = line.new(x1=londontime, x2=london_limit_right, y1=flondonhigh, y2=flondonhigh, color=LondonColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var londonl_line = line.new(x1=londontime, x2=london_limit_right, y1=flondonlow, y2=flondonlow, color=LondonColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var londono_line = line.new(x1=londontime, x2=london_limit_right, y1=flondonopen, y2=flondonopen, color=LondonColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var londonh_label = label.new(x=london_limit_right, y=flondonhigh, text=lhtext, style=DEFAULT_LABEL_STYLE, textcolor=LondonColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var londonl_label = label.new(x=london_limit_right, y=flondonlow, text=lltext, style=DEFAULT_LABEL_STYLE, textcolor=LondonColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var londono_label = label.new(x=london_limit_right, y=flondonopen, text=lotext, style=DEFAULT_LABEL_STYLE, textcolor=LondonColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(londonh_line, londontime)
        line.set_x2(londonh_line, london_limit_right)
        line.set_y1(londonh_line, flondonhigh)
        line.set_y2(londonh_line, flondonhigh)
        line.set_x1(londonl_line, londontime)
        line.set_x2(londonl_line, london_limit_right)
        line.set_y1(londonl_line, flondonlow)
        line.set_y2(londonl_line, flondonlow)
        line.set_x1(londono_line, londontime)
        line.set_x2(londono_line, london_limit_right)
        line.set_y1(londono_line, flondonopen)
        line.set_y2(londono_line, flondonopen)
        
        label.set_x(londonh_label, london_limit_right)
        label.set_y(londonh_label, flondonhigh)
        label.set_text(londonh_label, lhtext)
        label.set_x(londonl_label, london_limit_right)
        label.set_y(londonl_label, flondonlow)
        label.set_text(londonl_label, lltext)
        label.set_x(londono_label, london_limit_right)
        label.set_y(londono_label, flondonopen)
        label.set_text(londono_label, lotext)
        
        if mergebool
            f_LevelMerge(pricearray, labelarray, flondonhigh, londonh_label, LondonColor)
            f_LevelMerge(pricearray, labelarray, flondonlow, londonl_label, LondonColor)
            f_LevelMerge(pricearray, labelarray, flondonopen, londono_label, LondonColor)
//////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////

    if is_usrange_enabled
        //label.new(bar_index,high)
        us_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)


        if displayStyle == 'Right Anchored'
            ustime := get_limit_right(radistance)
            ustime

        var ush_line = line.new(x1=ustime, x2=us_limit_right, y1=fushigh, y2=fushigh, color=USColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var usl_line = line.new(x1=ustime, x2=us_limit_right, y1=fuslow, y2=fuslow, color=USColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var uso_line = line.new(x1=ustime, x2=us_limit_right, y1=fusopen, y2=fusopen, color=USColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var ush_label = label.new(x=us_limit_right, y=fushigh, text=lhtext, style=DEFAULT_LABEL_STYLE, textcolor=USColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var usl_label = label.new(x=us_limit_right, y=fuslow, text=lltext, style=DEFAULT_LABEL_STYLE, textcolor=USColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var uso_label = label.new(x=us_limit_right, y=fusopen, text=lotext, style=DEFAULT_LABEL_STYLE, textcolor=USColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(ush_line, ustime)
        line.set_x2(ush_line, us_limit_right)
        line.set_y1(ush_line, fushigh)
        line.set_y2(ush_line, fushigh)
        
        line.set_x1(usl_line, ustime)
        line.set_x2(usl_line, us_limit_right)
        line.set_y1(usl_line, fuslow)
        line.set_y2(usl_line, fuslow)
        
        line.set_x1(uso_line, ustime)
        line.set_x2(uso_line, us_limit_right)
        line.set_y1(uso_line, fusopen)
        line.set_y2(uso_line, fusopen)
        
        label.set_x(ush_label, us_limit_right)
        label.set_y(ush_label, fushigh)
        label.set_text(ush_label, ushtext)
        label.set_x(usl_label, us_limit_right)
        label.set_y(usl_label, fuslow)
        label.set_text(usl_label, usltext)
        label.set_x(uso_label, us_limit_right)
        label.set_y(uso_label, fusopen)
        label.set_text(uso_label, usotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, fushigh, ush_label, USColor)
            f_LevelMerge(pricearray, labelarray, fuslow, usl_label, USColor)
            f_LevelMerge(pricearray, labelarray, fusopen, uso_label, USColor)
    /////////////////////////////////

    if is_asiarange_enabled
        //label.new(bar_index,high)
        asia_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)

        if displayStyle == 'Right Anchored'
            asiatime := get_limit_right(radistance)
            asiatime

        var asiah_line = line.new(x1=asiatime, x2=asia_limit_right, y1=fasiahigh, y2=fasiahigh, color=AsiaColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var asial_line = line.new(x1=asiatime, x2=asia_limit_right, y1=fasialow, y2=fasialow, color=AsiaColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var asiao_line = line.new(x1=asiatime, x2=asia_limit_right, y1=fasiaopen, y2=fasiaopen, color=AsiaColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var asiah_label = label.new(x=asia_limit_right, y=fasiahigh, text=asiahtext, style=DEFAULT_LABEL_STYLE, textcolor=AsiaColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var asial_label = label.new(x=asia_limit_right, y=fasialow, text=asialtext, style=DEFAULT_LABEL_STYLE, textcolor=AsiaColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        var asiao_label = label.new(x=asia_limit_right, y=fasiaopen, text=asiaotext, style=DEFAULT_LABEL_STYLE, textcolor=AsiaColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(asiah_line, asiatime)
        line.set_x2(asiah_line, asia_limit_right)
        line.set_y1(asiah_line, fasiahigh)
        line.set_y2(asiah_line, fasiahigh)
        
        line.set_x1(asial_line, asiatime)
        line.set_x2(asial_line, asia_limit_right)
        line.set_y1(asial_line, fasialow)
        line.set_y2(asial_line, fasialow)
        
        line.set_x1(asiao_line, asiatime)
        line.set_x2(asiao_line, asia_limit_right)
        line.set_y1(asiao_line, fasiaopen)
        line.set_y2(asiao_line, fasiaopen)
        
        
        label.set_x(asiah_label, asia_limit_right)
        label.set_y(asiah_label, fasiahigh)
        label.set_text(asiah_label, asiahtext)
        label.set_x(asial_label, asia_limit_right)
        label.set_y(asial_label, fasialow)
        label.set_text(asial_label, asialtext)
        label.set_x(asiao_label, asia_limit_right)
        label.set_y(asiao_label, fasiaopen)
        label.set_text(asiao_label, asiaotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, fasiahigh, asiah_label, AsiaColor)
            f_LevelMerge(pricearray, labelarray, fasialow, asial_label, AsiaColor)
            f_LevelMerge(pricearray, labelarray, fasiaopen, asiao_label, AsiaColor)
//////////////////////////////////////////////////////////////////////////////////            
            
//////////////////////////////////////////////////////////////////////////////////
    if can_draw_intra
        intra_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intra_time := get_limit_right(radistance)
            intra_time


        var intra_line = line.new(x1=intra_time, x2=intra_limit_right, y1=intra_open, y2=intra_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intra_label = label.new(x=intra_limit_right, y=intra_open, text=iotext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intra_line, intra_time)
        line.set_x2(intra_line, intra_limit_right)
        line.set_y1(intra_line, intra_open)
        line.set_y2(intra_line, intra_open)
        label.set_x(intra_label, intra_limit_right)
        label.set_y(intra_label, intra_open)
        label.set_text(intra_label, iotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intra_open, intra_label, IntraColor)


//////////////////////////////////////////////////////////////////////////////////
//HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH HIGH
    if can_draw_intrah
        intrah_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intrah_time := get_limit_right(radistance)
            intrah_time



        var intrah_line = line.new(x1=intrah_time, x2=intrah_limit_right, y1=intrah_open, y2=intrah_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intrah_label = label.new(x=intrah_limit_right, y=intrah_open, text=pihtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intrah_line, intrah_time)
        line.set_x2(intrah_line, intrah_limit_right)
        line.set_y1(intrah_line, intrah_open)
        line.set_y2(intrah_line, intrah_open)
        label.set_x(intrah_label, intrah_limit_right)
        label.set_y(intrah_label, intrah_open)
        label.set_text(intrah_label, pihtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intrah_open, intrah_label, IntraColor)

//////////////////////////////////////////////////////////////////////////////////
//LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW LOW
    if can_draw_intral
        intral_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intral_time := get_limit_right(radistance)
            intral_time



        var intral_line = line.new(x1=intral_time, x2=intral_limit_right, y1=intral_open, y2=intral_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intral_label = label.new(x=intral_limit_right, y=intral_open, text=piltext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intral_line, intral_time)
        line.set_x2(intral_line, intral_limit_right)
        line.set_y1(intral_line, intral_open)
        line.set_y2(intral_line, intral_open)
        label.set_x(intral_label, intral_limit_right)
        label.set_y(intral_label, intral_open)
        label.set_text(intral_label, piltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intral_open, intral_label, IntraColor)

///////////////////////////////////////////////////////////////////////////////   

    if can_draw_intram
        intram_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        intram_time = intrah_time
        intram_open = (intral_open + intrah_open) / 2
        if displayStyle == 'Right Anchored'
            intram_time := get_limit_right(radistance)
            intram_time

        var intram_line = line.new(x1=intram_time, x2=intram_limit_right, y1=intram_open, y2=intram_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intram_label = label.new(x=intram_limit_right, y=intram_open, text=pimtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(intram_line, intram_time)
        line.set_x2(intram_line, intram_limit_right)
        line.set_y1(intram_line, intram_open)
        line.set_y2(intram_line, intram_open)
        label.set_x(intram_label, intram_limit_right)
        label.set_y(intram_label, intram_open)
        label.set_text(intram_label, pimtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intram_open, intram_label, IntraColor)

////////////////////////////////////////// MONDAY

    if is_monday_enabled
        monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time

        var monday_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_high, y2=monday_high, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monday_label = label.new(x=monday_limit_right, y=monday_high, text=pmonhtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_line, monday_time)
        line.set_x2(monday_line, monday_limit_right)
        line.set_y1(monday_line, monday_high)
        line.set_y2(monday_line, monday_high)
        label.set_x(monday_label, monday_limit_right)
        label.set_y(monday_label, monday_high)
        label.set_text(monday_label, pmonhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_high, monday_label, MondayColor)


    if is_monday_enabled
        monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time



        var monday_low_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_low, y2=monday_low, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monday_low_label = label.new(x=monday_limit_right, y=monday_low, text=pmonltext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_low_line, monday_time)
        line.set_x2(monday_low_line, monday_limit_right)
        line.set_y1(monday_low_line, monday_low)
        line.set_y2(monday_low_line, monday_low)
        label.set_x(monday_low_label, monday_limit_right)
        label.set_y(monday_low_label, monday_low)
        label.set_text(monday_low_label, pmonltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_low, monday_low_label, MondayColor)



    if is_monday_mid
        mondaym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)

        mondaym_open = (monday_high + monday_low) / 2
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time

        var mondaym_line = line.new(x1=monday_time, x2=mondaym_limit_right, y1=mondaym_open, y2=mondaym_open, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var mondaym_label = label.new(x=mondaym_limit_right, y=mondaym_open, text=pmonmtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(mondaym_line, monday_time)
        line.set_x2(mondaym_line, mondaym_limit_right)
        line.set_y1(mondaym_line, mondaym_open)
        line.set_y2(mondaym_line, mondaym_open)
        label.set_x(mondaym_label, mondaym_limit_right)
        label.set_y(mondaym_label, mondaym_open)
        label.set_text(mondaym_label, pmonmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, mondaym_open, mondaym_label, MondayColor)


//////////////////////////////////////////////////////////////////////////////////
////////////////////////DAILY OPEN DAILY OPEN DAILY OPEN DAILY OPEN DAILY OPEN DAILY OPEN DAILY OPEN

    if is_daily_enabled
        daily_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            daily_time := get_limit_right(radistance)
            daily_time

        var daily_line = line.new(x1=daily_time, x2=daily_limit_right, y1=daily_open, y2=daily_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var daily_label = label.new(x=daily_limit_right, y=daily_open, text=dotext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(daily_line, daily_time)
        line.set_x2(daily_line, daily_limit_right)
        line.set_y1(daily_line, daily_open)
        line.set_y2(daily_line, daily_open)
        label.set_x(daily_label, daily_limit_right)
        label.set_y(daily_label, daily_open)
        label.set_text(daily_label, dotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, daily_open, daily_label, DailyColor)

//////////////////////////////////////////////////////////////////////////////////
//////////////////DAILY HIGH DAILY HIGH DAILY HIGH DAILY HIGH DAILY HIGH DAILY HIGH DAILY HIGH 

    if is_dailyrange_enabled
        dailyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyh_time := get_limit_right(radistance)
            dailyh_time
        // draw tails before lines for better visual


        var dailyh_line = line.new(x1=dailyh_time, x2=dailyh_limit_right, y1=dailyh_open, y2=dailyh_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailyh_label = label.new(x=dailyh_limit_right, y=dailyh_open, text=pdhtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyh_line, dailyh_time)
        line.set_x2(dailyh_line, dailyh_limit_right)
        line.set_y1(dailyh_line, dailyh_open)
        line.set_y2(dailyh_line, dailyh_open)
        label.set_x(dailyh_label, dailyh_limit_right)
        label.set_y(dailyh_label, dailyh_open)
        label.set_text(dailyh_label, pdhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyh_open, dailyh_label, DailyColor)


//////////////////////////////////////////////////////////////////////////////////
//////////////////DAILY LOW DAILY LOW DAILY LOW DAILY LOW DAILY LOW DAILY LOW DAILY LOW DAILY LOW 

    if is_dailyrange_enabled
        dailyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyl_time := get_limit_right(radistance)
            dailyl_time


        var dailyl_line = line.new(x1=dailyl_time, x2=dailyl_limit_right, y1=dailyl_open, y2=dailyl_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailyl_label = label.new(x=dailyl_limit_right, y=dailyl_open, text=pdltext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyl_line, dailyl_time)
        line.set_x2(dailyl_line, dailyl_limit_right)
        line.set_y1(dailyl_line, dailyl_open)
        line.set_y2(dailyl_line, dailyl_open)
        label.set_x(dailyl_label, dailyl_limit_right)
        label.set_y(dailyl_label, dailyl_open)
        label.set_text(dailyl_label, pdltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyl_open, dailyl_label, DailyColor)



//////////////////////////////////////////////////////////////////////////////// Daily MID

    if is_dailym_enabled
        dailym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        dailym_time = dailyh_time
        dailym_open = (dailyl_open + dailyh_open) / 2
        if displayStyle == 'Right Anchored'
            dailym_time := get_limit_right(radistance)
            dailym_time
        var dailym_line = line.new(x1=dailym_time, x2=dailym_limit_right, y1=dailym_open, y2=dailym_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailym_label = label.new(x=dailym_limit_right, y=dailym_open, text=pdmtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(dailym_line, dailym_time)
        line.set_x2(dailym_line, dailym_limit_right)
        line.set_y1(dailym_line, dailym_open)
        line.set_y2(dailym_line, dailym_open)
        label.set_x(dailym_label, dailym_limit_right)
        label.set_y(dailym_label, dailym_open)
        label.set_text(dailym_label, pdmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailym_open, dailym_label, DailyColor)


//////////////////////////////////////////////////////////////////////////////////


    if is_weekly_enabled
        weekly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        cweekly_time = weekly_time
        if displayStyle == 'Right Anchored'
            cweekly_time := get_limit_right(radistance)
            cweekly_time


        var weekly_line = line.new(x1=cweekly_time, x2=weekly_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weekly_label = label.new(x=weekly_limit_right, y=weekly_open, text=wotext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weekly_line, cweekly_time)
        line.set_x2(weekly_line, weekly_limit_right)
        line.set_y1(weekly_line, weekly_open)
        line.set_y2(weekly_line, weekly_open)
        label.set_x(weekly_label, weekly_limit_right)
        label.set_y(weekly_label, weekly_open)
        label.set_text(weekly_label, wotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weekly_open, weekly_label, WeeklyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label
    // if is_weekly_open and can_show_daily
            // label.set_text(weekly_label, "DO / WO            ")

//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////// WEEKLY HIGH WEEKLY HIGH WEEKLY HIGH


    if is_weeklyrange_enabled
        weeklyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyh_time := get_limit_right(radistance)
            weeklyh_time


        var weeklyh_line = line.new(x1=weeklyh_time, x2=weeklyh_limit_right, y1=weeklyh_open, y2=weeklyh_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklyh_label = label.new(x=weeklyh_limit_right, y=weeklyh_open, text=pwhtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyh_line, weeklyh_time)
        line.set_x2(weeklyh_line, weeklyh_limit_right)
        line.set_y1(weeklyh_line, weeklyh_open)
        line.set_y2(weeklyh_line, weeklyh_open)
        label.set_x(weeklyh_label, weeklyh_limit_right)
        label.set_y(weeklyh_label, weeklyh_open)
        label.set_text(weeklyh_label, pwhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyh_open, weeklyh_label, WeeklyColor)

//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////// WEEKLY LOW WEEKLY LOW WEEKLY LOW


    if is_weeklyrange_enabled
        weeklyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyl_time := get_limit_right(radistance)
            weeklyl_time


        var weeklyl_line = line.new(x1=weeklyl_time, x2=weeklyl_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklyl_label = label.new(x=weeklyl_limit_right, y=weeklyl_open, text=pwltext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyl_line, weeklyl_time)
        line.set_x2(weeklyl_line, weeklyl_limit_right)
        line.set_y1(weeklyl_line, weeklyl_open)
        line.set_y2(weeklyl_line, weeklyl_open)
        label.set_x(weeklyl_label, weeklyl_limit_right)
        label.set_y(weeklyl_label, weeklyl_open)
        label.set_text(weeklyl_label, pwltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyl_open, weeklyl_label, WeeklyColor)



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// Weekly MID

    if is_weekly_mid
        weeklym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        weeklym_time = weeklyh_time
        weeklym_open = (weeklyl_open + weeklyh_open) / 2
        if displayStyle == 'Right Anchored'
            weeklym_time := get_limit_right(radistance)
            weeklym_time

        var weeklym_line = line.new(x1=weeklym_time, x2=weeklym_limit_right, y1=weeklym_open, y2=weeklym_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklym_label = label.new(x=weeklym_limit_right, y=weeklym_open, text=pwmtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(weeklym_line, weeklym_time)
        line.set_x2(weeklym_line, weeklym_limit_right)
        line.set_y1(weeklym_line, weeklym_open)
        line.set_y2(weeklym_line, weeklym_open)
        label.set_x(weeklym_label, weeklym_limit_right)
        label.set_y(weeklym_label, weeklym_open)
        label.set_text(weeklym_label, pwmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklym_open, weeklym_label, WeeklyColor)
////////////////////////////////////////////////////////////////////////////////// YEEEAARRLLYY LOW LOW LOW


    if is_yearlyrange_enabled
        yearlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearlyl_time := get_limit_right(radistance)
            yearlyl_time


        var yearlyl_line = line.new(x1=yearlyl_time, x2=yearlyl_limit_right, y1=yearlyl_open, y2=yearlyl_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlyl_label = label.new(x=yearlyl_limit_right, y=yearlyl_open, text=cyltext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(yearlyl_line, yearlyl_time)
        line.set_x2(yearlyl_line, yearlyl_limit_right)
        line.set_y1(yearlyl_line, yearlyl_open)
        line.set_y2(yearlyl_line, yearlyl_open)
        label.set_x(yearlyl_label, yearlyl_limit_right)
        label.set_y(yearlyl_label, yearlyl_open)
        label.set_text(yearlyl_label, cyltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlyl_open, yearlyl_label, YearlyColor)



//////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////// YEEEAARRLLYY HIGH HIGH HIGH


    if is_yearlyrange_enabled
        yearlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearlyh_time := get_limit_right(radistance)
            yearlyh_time


        var yearlyh_line = line.new(x1=yearlyh_time, x2=yearlyh_limit_right, y1=yearlyh_open, y2=yearlyh_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlyh_label = label.new(x=yearlyh_limit_right, y=yearlyh_open, text=cyhtext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(yearlyh_line, yearlyh_time)
        line.set_x2(yearlyh_line, yearlyh_limit_right)
        line.set_y1(yearlyh_line, yearlyh_open)
        line.set_y2(yearlyh_line, yearlyh_open)
        label.set_x(yearlyh_label, yearlyh_limit_right)
        label.set_y(yearlyh_label, yearlyh_open)
        label.set_text(yearlyh_label, cyhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlyh_open, yearlyh_label, YearlyColor)



//////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////// YEEEAARRLLYY OPEN


    if is_yearly_enabled
        yearly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearly_time := get_limit_right(radistance)
            yearly_time


        var yearly_line = line.new(x1=yearly_time, x2=yearly_limit_right, y1=yearly_open, y2=yearly_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)

        var yearly_label = label.new(x=yearly_limit_right, y=yearly_open, text=yotext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)



        line.set_x1(yearly_line, yearly_time)
        line.set_x2(yearly_line, yearly_limit_right)
        line.set_y1(yearly_line, yearly_open)
        line.set_y2(yearly_line, yearly_open)
        label.set_x(yearly_label, yearly_limit_right)
        label.set_y(yearly_label, yearly_open)
        label.set_text(yearly_label, yotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearly_open, yearly_label, YearlyColor)



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// yearly MID

    if is_yearly_mid
        yearlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        yearlym_time = yearlyh_time
        yearlym_open = (yearlyl_open + yearlyh_open) / 2
        if displayStyle == 'Right Anchored'
            yearlym_time := get_limit_right(radistance)
            yearlym_time

        var yearlym_line = line.new(x1=yearlym_time, x2=yearlym_limit_right, y1=yearlym_open, y2=yearlym_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlym_label = label.new(x=yearlym_limit_right, y=yearlym_open, text=cymtext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(yearlym_line, yearlym_time)
        line.set_x2(yearlym_line, yearlym_limit_right)
        line.set_y1(yearlym_line, yearlym_open)
        line.set_y2(yearlym_line, yearlym_open)
        label.set_x(yearlym_label, yearlym_limit_right)
        label.set_y(yearlym_label, yearlym_open)
        label.set_text(yearlym_label, cymtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlym_open, yearlym_label, YearlyColor)


////////////////////////////////////////////////////////////////////////////////// QUATERLLYYYYY OPEN


    if is_quarterly_enabled
        quarterly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterly_time := get_limit_right(radistance)
            quarterly_time


        var quarterly_line = line.new(x1=quarterly_time, x2=quarterly_limit_right, y1=quarterly_open, y2=quarterly_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterly_label = label.new(x=quarterly_limit_right, y=quarterly_open, text=qotext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterly_line, quarterly_time)
        line.set_x2(quarterly_line, quarterly_limit_right)
        line.set_y1(quarterly_line, quarterly_open)
        line.set_y2(quarterly_line, quarterly_open)
        label.set_x(quarterly_label, quarterly_limit_right)
        label.set_y(quarterly_label, quarterly_open)
        label.set_text(quarterly_label, qotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterly_open, quarterly_label, quarterlyColor)



//////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////// QUATERLLYYYYY High


    if is_quarterlyrange_enabled
        quarterlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterlyh_time := get_limit_right(radistance)
            quarterlyh_time


        var quarterlyh_line = line.new(x1=quarterlyh_time, x2=quarterlyh_limit_right, y1=quarterlyh_open, y2=quarterlyh_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlyh_label = label.new(x=quarterlyh_limit_right, y=quarterlyh_open, text=pqhtext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterlyh_line, quarterlyh_time)
        line.set_x2(quarterlyh_line, quarterlyh_limit_right)
        line.set_y1(quarterlyh_line, quarterlyh_open)
        line.set_y2(quarterlyh_line, quarterlyh_open)
        label.set_x(quarterlyh_label, quarterlyh_limit_right)
        label.set_y(quarterlyh_label, quarterlyh_open)
        label.set_text(quarterlyh_label, pqhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlyh_open, quarterlyh_label, quarterlyColor)



//////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////// QUATERLLYYYYY Low


    if is_quarterlyrange_enabled
        quarterlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterlyl_time := get_limit_right(radistance)
            quarterlyl_time


        var quarterlyl_line = line.new(x1=quarterlyl_time, x2=quarterlyl_limit_right, y1=quarterlyl_open, y2=quarterlyl_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlyl_label = label.new(x=quarterlyl_limit_right, y=quarterlyl_open, text=pqltext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterlyl_line, quarterlyl_time)
        line.set_x2(quarterlyl_line, quarterlyl_limit_right)
        line.set_y1(quarterlyl_line, quarterlyl_open)
        line.set_y2(quarterlyl_line, quarterlyl_open)
        label.set_x(quarterlyl_label, quarterlyl_limit_right)
        label.set_y(quarterlyl_label, quarterlyl_open)

        label.set_text(quarterlyl_label, pqltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlyl_open, quarterlyl_label, quarterlyColor)



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// QUATERLLYYYYY MID

    if is_quarterly_mid
        quarterlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        quarterlym_time = quarterlyh_time
        quarterlym_open = (quarterlyl_open + quarterlyh_open) / 2
        if displayStyle == 'Right Anchored'
            quarterlym_time := get_limit_right(radistance)
            quarterlym_time
        var quarterlym_line = line.new(x1=quarterlym_time, x2=quarterlym_limit_right, y1=quarterlym_open, y2=quarterlym_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlym_label = label.new(x=quarterlym_limit_right, y=quarterlym_open, text=pqmtext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(quarterlym_line, quarterlym_time)
        line.set_x2(quarterlym_line, quarterlym_limit_right)
        line.set_y1(quarterlym_line, quarterlym_open)
        line.set_y2(quarterlym_line, quarterlym_open)
        label.set_x(quarterlym_label, quarterlym_limit_right)
        label.set_y(quarterlym_label, quarterlym_open)

        label.set_text(quarterlym_label, pqmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlym_open, quarterlym_label, quarterlyColor)

////////////////////////////////////////////////////////////////////////////////// Monthly LOW LOW LOW


    if is_monthlyrange_enabled
        monthlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyl_time := get_limit_right(radistance)
            monthlyl_time


        var monthlyl_line = line.new(x1=monthlyl_time, x2=monthlyl_limit_right, y1=monthlyl_open, y2=monthlyl_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyl_label = label.new(x=monthlyl_limit_right, y=monthlyl_open, text=pmltext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyl_line, monthlyl_time)
        line.set_x2(monthlyl_line, monthlyl_limit_right)
        line.set_y1(monthlyl_line, monthlyl_open)
        line.set_y2(monthlyl_line, monthlyl_open)
        label.set_x(monthlyl_label, monthlyl_limit_right)
        label.set_y(monthlyl_label, monthlyl_open)
        label.set_text(monthlyl_label, pmltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyl_open, monthlyl_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label


//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////// MONTHLY HIGH HIGH HIGH



    if is_monthlyrange_enabled
        monthlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyh_time := get_limit_right(radistance)
            monthlyh_time


        var monthlyh_line = line.new(x1=monthlyh_time, x2=monthlyh_limit_right, y1=monthlyh_open, y2=monthlyh_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyh_label = label.new(x=monthlyh_limit_right, y=monthlyh_open, text=pmhtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyh_line, monthlyl_time)
        line.set_x2(monthlyh_line, monthlyh_limit_right)
        line.set_y1(monthlyh_line, monthlyh_open)
        line.set_y2(monthlyh_line, monthlyh_open)
        label.set_x(monthlyh_label, monthlyh_limit_right)
        label.set_y(monthlyh_label, monthlyh_open)
        label.set_text(monthlyh_label, pmhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyh_open, monthlyh_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label

//////////////////////////////////////////////////////////////////////////////// MONTHLY MID

    if is_monthly_mid
        monthlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        monthlym_time = monthlyh_time
        monthlym_open = (monthlyl_open + monthlyh_open) / 2
        if displayStyle == 'Right Anchored'
            monthlym_time := get_limit_right(radistance)
            monthlym_time
        var monthlym_line = line.new(x1=monthlym_time, x2=monthlym_limit_right, y1=monthlym_open, y2=monthlym_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlym_label = label.new(x=monthlym_limit_right, y=monthlym_open, text=pmmtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(monthlym_line, monthlym_time)
        line.set_x2(monthlym_line, monthlym_limit_right)
        line.set_y1(monthlym_line, monthlym_open)
        line.set_y2(monthlym_line, monthlym_open)
        label.set_x(monthlym_label, monthlym_limit_right)
        label.set_y(monthlym_label, monthlym_open)
        label.set_text(monthlym_label, pmmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlym_open, monthlym_label, MonthlyColor)
//////////////////////////////////////////////////////////////////////////////////



    if is_monthly_enabled
        monthly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthly_time := get_limit_right(radistance)
            monthly_time

        var monthlyLine = line.new(x1=monthly_time, x2=monthly_limit_right, y1=monthly_open, y2=monthly_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyLabel = label.new(x=monthly_limit_right, y=monthly_open, text=motext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyLine, monthly_time)
        line.set_x2(monthlyLine, monthly_limit_right)
        line.set_y1(monthlyLine, monthly_open)
        line.set_y2(monthlyLine, monthly_open)
        label.set_x(monthlyLabel, monthly_limit_right)
        label.set_y(monthlyLabel, monthly_open)
        label.set_text(monthlyLabel, motext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthly_open, monthlyLabel, MonthlyColor)


/////////////////////////////////////////////////////////////////////////////

        // the monthly open can be the weekly open (monday 1st) and/or daily open too
        // only the monthly will be draw, in these case we update its label
        // if is_monthly_open
        //     if can_show_daily
        //         label.set_text(monthlyLabel, "DO / MO            ")
        //     if is_weekly_open
        //         if can_show_weekly
        //             label.set_text(monthlyLabel, "WO / MO            ")
        //         if can_show_daily and can_show_weekly
        //             label.set_text(monthlyLabel, "DO / WO / MO                ")

        // the start of the line is drew from the first week of the month
        // if the first day of the weekly candle (monday) is the 2nd of the month
        // we fix the start of the line position on the Prev weekly candle
        if timeframe.isweekly and dayofweek(monthly_time) != dayofweek.monday
            line.set_x1(monthlyLine, monthly_time - (weekly_time - weekly_time[1]))

var inputHighlightIntermediates = input(true, 'Highlight Intermediate Swing Highs and Lows')
var inputIntermediateSize = input.string('Tiny', 'Intermediate Swing Label Size', options=['Auto', 'Tiny', 'Small', 'Normal'])
var inputShowShortTermSwings = input(false, 'Short Term Swings')
var inputPivotBars = input(2, 'Pivot Candles')
var highcolor = input.color(color.red, title="High", tooltip="select a color for ST/IT Highs")
var lowcolor = input.color(color.green, title="Low", tooltip="select a color for ST/IT Lows")

var intermediateLabelSize = inputIntermediateSize == 'Auto' ? size.auto : inputIntermediateSize == 'Tiny' ? size.tiny : inputIntermediateSize == 'Small' ? size.small : size.normal

// Parallel arrays for Swing High Data
var float[] swingHighs = array.new_float()
var label[] swingHighLabels = array.new_label()
var bool[] swingHighIsHigher = array.new_bool()
var bool[] swingHighIsIntermediate = array.new_bool()

// Parallel arrays for Swing Low Data
var float[] swingLows = array.new_float()
var label[] swingLowLabels = array.new_label()
var bool[] swingLowIsLower = array.new_bool()
var bool[] swingLowIsIntermediate = array.new_bool()

// see last element pushed an an array
array_peek(arrayId) =>
    int arraySize = array.size(arrayId)
    if arraySize > 0
        array.get(arrayId, arraySize - 1)
    else
        na

// filters out swings that were not intermediate swings after all swings have been recorded.
remove_short_term_swings() =>
    if not inputShowShortTermSwings and barstate.islast
        var swingHighCount = array.size(swingHighLabels)
        var swingLowCount = array.size(swingLowLabels)

        for i = 0 to swingHighCount - 1 by 1
            if not array.get(swingHighIsIntermediate, i)
                label.delete(array.get(swingHighLabels, i))

        for i = 0 to swingLowCount - 1 by 1
            if not array.get(swingLowIsIntermediate, i)
                label.delete(array.get(swingLowLabels, i))


// detect swing highs and lows
swingHighPrice = ta.pivothigh(high, inputPivotBars, inputPivotBars)
swingLowPrice = ta.pivotlow(low, inputPivotBars, inputPivotBars)


if not na(swingHighPrice)
    lastSwingHighPrice = array_peek(swingHighs)
    isHigherHigh = swingHighPrice > lastSwingHighPrice
    isLowerHigh = swingHighPrice < lastSwingHighPrice
    swingLabel = label.new(bar_index[inputPivotBars], swingHighPrice, color=highcolor, yloc=yloc.price, style=label.style_circle, size=size.tiny)

    // check if last swing high was intermediate
    if isLowerHigh and array_peek(swingHighIsHigher)
        // lower high after a higher high means the previous swing high was intermediate
        if inputHighlightIntermediates
            label.set_size(array_peek(swingHighLabels), intermediateLabelSize)
            array.set(swingHighIsIntermediate, array.size(swingHighIsIntermediate) - 1, true)

    // save swing
    array.push(swingHighs, swingHighPrice)
    array.push(swingHighLabels, swingLabel)
    array.push(swingHighIsHigher, isHigherHigh)
    array.push(swingHighIsIntermediate, false)  // can be filled in later, if a lower high forms next

if not na(swingLowPrice)
    lastSwingLowPrice = array_peek(swingLows)
    isHigherLow = swingLowPrice > lastSwingLowPrice
    isLowerLow = swingLowPrice < lastSwingLowPrice
    swingLabel = label.new(bar_index[inputPivotBars], swingLowPrice, color=lowcolor, yloc=yloc.price, style=label.style_circle, size=size.tiny)

    // check if last swing low was intermediate
    if isHigherLow and array_peek(swingLowIsLower)
        // higher low after a lower low means the previous swing low was intermediate
        if inputHighlightIntermediates
            label.set_size(array_peek(swingLowLabels), intermediateLabelSize)
            array.set(swingLowIsIntermediate, array.size(swingLowIsIntermediate) - 1, true)

    // save swing
    array.push(swingLows, swingLowPrice)
    array.push(swingLowLabels, swingLabel)
    array.push(swingLowIsLower, isLowerLow)
    array.push(swingLowIsIntermediate, false)  // can be filled in later if a higher low forms next


remove_short_term_swings()


//IMBALANCE
show_IMB = input.bool(true, "Imbalance", group='IMBALANCE')
imbalancecolor = input.color(color.yellow, title="Imbalance Color", group='IMBALANCE')
fvgTransparency  = input(title="Transparency", defval=60, group='IMBALANCE')
fvgboxLength = input.int(title='Length', defval=0, group='IMBALANCE')

fvgisUp(index) =>
    close[index] > open[index]

fvgisDown(index) =>
    close[index] < open[index]


fvgisObUp(index) =>
    fvgisDown(index + 1) and fvgisUp(index) and close[index] > high[index + 1]


fvgisObDown(index) =>
    fvgisUp(index + 1) and fvgisDown(index) and close[index] < low[index + 1]


bullishFvg = low[0] > high[2]
bearishFvg = high[0] < low[2]
if bullishFvg and show_IMB
    box.new(left=bar_index - 1, top=low[0], right=bar_index + fvgboxLength, bottom=high[2], bgcolor=color.new(imbalancecolor, fvgTransparency), border_color=color.new(imbalancecolor, fvgTransparency))
if bearishFvg and show_IMB
    box.new(left=bar_index - 1, top=low[2], right=bar_index + fvgboxLength, bottom=high[0], bgcolor=color.new(imbalancecolor, fvgTransparency), border_color=color.new(imbalancecolor, fvgTransparency))
//////////////////// FVG //////////////////

//---------------------------------opening gapes intrigation---------------------------------------------


import cryptonnnite/helpers/1 as helpers

type gap
    float high
    float low
    int start
    int end

var string nwogGroup = "New Week Opening Gap"
var string ndogGroup = "New Day Opening Gap"
var string generalSettings = "General Settings"
var string openLineSettings = "Week & Day Open"

bool showNWOG = input.bool(true, "", inline = "1", group = nwogGroup)
string nwogLabel = input.string("NWOG", "", inline = "1", group = nwogGroup)
color nwogBg = input.color(color.rgb(164, 249, 73, 85), "", inline = "1", group = nwogGroup)
bool showNwogCE = input.bool(false, "NWOG C.E.", tooltip = "C.E. - Consequent Encroachment or 'middle point' of any Gap or Inefficiency.", group = nwogGroup, inline = "2")
string nwogCEStyle = input.string("dotted", "", options = ["dotted", "dashed", "solid"], group = nwogGroup, inline = "2")
color nwogCEColor = input.color(color.blue, "", group = nwogGroup, inline = "2")
string nwogLabelXPosition = input.string('right', title = "Label", options = ["left", "center", "right"], inline = "5", group = nwogGroup)
string nwogLabelYPosition = input.string('top', title = "", options = ["top", "center", "bottom"], inline = "5", group = nwogGroup)
string nwogLabelSize = input.string('small', title = "", options = ["tiny", "small", "normal", "large", "huge"], inline = "5", group = nwogGroup)
color nwogLabelColor = input.color(color.black, "", inline = "5", group = nwogGroup)
int nwogsAmount = input.int(4, "Previous NWOGs", minval = 1, maxval = 100, inline = "3", group = nwogGroup)
color previousNwogBg = input.color(color.rgb(0, 0, 0, 90), "", inline = "3", group = nwogGroup)
bool extendAllNwogs = input.bool(false, "Extend Previous NWOGs", group = nwogGroup)
bool extendToCurrentDayCloseTime = input.bool(true, "Extend to Current Day", tooltip = "Otherwise it will be extended to the end of the week", group = nwogGroup)

bool showNDOG = input.bool(true, "", inline = "2", group = ndogGroup)
string ndogLabel = input.string("NDOG", "", inline = "2", group = ndogGroup)
color ndogBg = input.color(color.rgb(255, 235, 59, 85), "", inline = "2", group = ndogGroup)
bool showNdogCE = input.bool(false, "NDOG C.E.", tooltip = "C.E. - Consequent Encroachment or 'middle point' of any Gap or Inefficiency.", group = ndogGroup, inline = "3")
string ndogCEStyle = input.string("dotted", "", options = ["dotted", "dashed", "solid"], group = ndogGroup, inline = "3")
color ndogCEColor = input.color(color.blue, "", group = ndogGroup, inline = "3")
string ndogLabelXPosition = input.string('right', title = "Label", options = ["left", "center", "right"], inline = "5", group = ndogGroup)
string ndogLabelYPosition = input.string('top', title = "", options = ["top", "center", "bottom"], inline = "5", group = ndogGroup)
string ndogLabelSize = input.string('small', title = "", options = ["tiny", "small", "normal", "large", "huge"], inline = "5", group = ndogGroup)
color ndogLabelColor = input.color(color.black, "", inline = "5", group = ndogGroup)
int ndogsAmount = input.int(4, "Previous NDOG", minval = 1, maxval = 100, inline = "4", group = ndogGroup)
color previousNdogBg = input.color(color.rgb(0, 0, 0, 90), "", inline = "4", group = ndogGroup)
bool extendAllNdogs = input.bool(false, "Extend Previous NDOGs", group = ndogGroup)

bool eventHorizon = input.bool(false, "Event Horizon", inline = "2", group = generalSettings)
string eventHorizonLineStyle = input.string("dashed", "", options = ["dotted", "dashed", "solid"], group = generalSettings, inline = "2")
color eventHorizonLineColor = input.color(color.red, "", inline = "2", group = generalSettings)

bool fiveToSixGap = input.bool(true, "5pm to 6pm GAP", tooltip = "This option will show only 5pm to 6pm gaps. If you will see at the daily timeframe there is a big difference between previous day close and current day open GAP and 5pm to 6pm GAP. This option allows you to choose which GAP to use.", group = generalSettings)
bool showPriceLabels = input.bool(false, "Price Labels", inline = "1", group = generalSettings)
string priceLabelSize = input.string('small', title = "", options = ["tiny", "small", "normal", "large", "huge"], inline = "1", group = generalSettings)
color priceLabelColor = input.color(color.black, "", inline = "1", group = generalSettings)
bool showDateLabel = input.bool(true, "Show date label", group = generalSettings)
string dateFormat = input.string("dd.MM", title = "Date Format", options = ["dd.MM", "MM.dd", "dd.MM.yy", "MM.dd.yy"], group = generalSettings)

getGapData() =>
    gap.new(math.max(close[1], open), math.min(close[1], open), time, time_close)

getDayOfWeekLabel(_dayofweek) =>
    switch _dayofweek
        dayofweek.sunday => "Sun"
        dayofweek.monday => "Mon"
        dayofweek.tuesday => "Tue"
        dayofweek.wednesday => "Wed"
        dayofweek.thursday => "Thu"
        dayofweek.friday => "Fri"
        dayofweek.saturday => "Sat"

gap weekOpeningGap = request.security(syminfo.tickerid, "1W", getGapData(), lookahead =  barmerge.lookahead_on)
[dayOpeningGap, currentDayTimeClose] = request.security(syminfo.tickerid, "1D", [getGapData(), time_close], lookahead =  barmerge.lookahead_on)
[isNewWeek, hourPreviousBarClose, hourCurrentBarOpen] = request.security(syminfo.tickerid, "240", [helpers.isNewbar("W"), close[1], open], lookahead =  barmerge.lookahead_on)

if timeframe.isintraday and helpers.isNewbar("D") and fiveToSixGap
    dayOpeningGap.high := math.max(close[1], open)
    dayOpeningGap.low := math.min(close[1], open)

if timeframe.multiplier < 60
    if isNewWeek and fiveToSixGap
        weekOpeningGap.high := math.max(hourPreviousBarClose, hourCurrentBarOpen)
        weekOpeningGap.low := math.min(hourPreviousBarClose, hourCurrentBarOpen)
else if (timeframe.isdaily or timeframe.isintraday) and helpers.isNewbar("W") and fiveToSixGap
    weekOpeningGap.high := math.max(close[1], open)
    weekOpeningGap.low := math.min(close[1], open)

var array<box> nwogArray = array.new<box>(0)
var array<line> nwogCEArray = array.new<line>(0)
var array<label> nwogHighLabel = array.new<label>(0)
var array<label> nwogCELabel = array.new<label>(0)
var array<label> nwogLowLabel = array.new<label>(0)

var array<box> ndogArray = array.new<box>(0)
var array<line> ndogCEArray = array.new<line>(0)
var array<label> ndogHighLabel = array.new<label>(0)
var array<label> ndogCELabel = array.new<label>(0)
var array<label> ndogLowLabel = array.new<label>(0)

var line eventHorizonLine = na

if showNWOG and (timeframe.isdaily or timeframe.isintraday) 
    if helpers.isNewbar("W") // if (hour(time, "America/New_York") == 9 and minute(time, America/New_York) == 30 and nineThirtyGap) or (not nineThirtyGap and helpers.isNewbar("W"))
        string weekLabel = showDateLabel ? str.format_time(weekOpeningGap.start, dateFormat, syminfo.timezone) + " - " + str.format_time(weekOpeningGap.end, dateFormat, syminfo.timezone) + " | " + nwogLabel : nwogLabel
        float nwogCePrice = (weekOpeningGap.high + weekOpeningGap.low) / 2
        
        array.push(nwogArray, box.new(weekOpeningGap.start, weekOpeningGap.high, weekOpeningGap.end, weekOpeningGap.low, xloc = xloc.bar_time, bgcolor = nwogBg, border_width = 0, text = weekLabel, text_size = helpers.getTextSize(nwogLabelSize), text_halign = helpers.getBoxTextPosition(nwogLabelXPosition), text_valign = helpers.getBoxTextPosition(nwogLabelYPosition), text_color = nwogLabelColor))
        
        if showNwogCE
            array.push(nwogCEArray, line.new(weekOpeningGap.start, nwogCePrice, weekOpeningGap.end, nwogCePrice, xloc = xloc.bar_time, style = helpers.getLineStyle(nwogCEStyle), color = nwogCEColor))
        
        if showPriceLabels
            array.push(nwogHighLabel, label.new(weekOpeningGap.end, weekOpeningGap.high, str.tostring(weekOpeningGap.high, format.mintick), style = label.style_label_lower_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))
            array.push(nwogCELabel, label.new(weekOpeningGap.end, nwogCePrice, str.tostring(nwogCePrice, format.mintick), style = label.style_label_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))
            array.push(nwogLowLabel, label.new(weekOpeningGap.end, weekOpeningGap.low, str.tostring(weekOpeningGap.low, format.mintick), style = label.style_label_upper_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))

        if array.size(nwogArray) > nwogsAmount
            box.delete(array.shift(nwogArray))
            
            if showNwogCE
                line.delete(array.shift(nwogCEArray))
            
            if showPriceLabels
                label.delete(array.shift(nwogHighLabel))
                label.delete(array.shift(nwogCELabel))
                label.delete(array.shift(nwogLowLabel))
        
        if eventHorizon and array.size(nwogArray) > 1
            box currentNwog = array.last(nwogArray)
            box previousNwog = array.get(nwogArray, array.size(nwogArray) - 2)

            float currentNwog_high = box.get_top(currentNwog)
            float currentNwog_low = box.get_bottom(currentNwog)
            
            float previousNwog_high = box.get_top(previousNwog)
            float previousNwog_low = box.get_bottom(previousNwog)
            
            float eventHorizonLevel = 0.0

            if currentNwog_high > previousNwog_high and currentNwog_low > previousNwog_high
                eventHorizonLevel := (currentNwog_low + previousNwog_high) / 2
            else if previousNwog_high > currentNwog_high and previousNwog_low > currentNwog_high
                eventHorizonLevel := (previousNwog_low + currentNwog_high) / 2

            eventHorizonLine := line.new(weekOpeningGap.start, eventHorizonLevel, weekOpeningGap.end, eventHorizonLevel, xloc = xloc.bar_time, style = helpers.getLineStyle(eventHorizonLineStyle), color = eventHorizonLineColor)
            line.delete(eventHorizonLine[1])

    if helpers.isNewbar("D") 
        if extendAllNwogs and array.size(nwogArray) > 0
            for i = array.size(nwogArray) - 1 to 0
                extendTo = extendToCurrentDayCloseTime ? currentDayTimeClose : weekOpeningGap.end
                box.set_right(array.get(nwogArray, i), extendTo)
                
                if i != array.size(nwogArray) - 1
                    box.set_bgcolor(array.get(nwogArray, i), previousNwogBg)

                if showNwogCE
                    line.set_x2(array.get(nwogCEArray, i), extendTo)
                
                if showPriceLabels
                    label.set_x(array.get(nwogHighLabel, i), extendTo)
                    label.set_x(array.get(nwogCELabel, i), extendTo)
                    label.set_x(array.get(nwogLowLabel, i), extendTo)

        if extendToCurrentDayCloseTime and array.size(nwogArray) > 0
            box.set_right(array.last(nwogArray), currentDayTimeClose)
            
            if showNwogCE
                line.set_x2(array.last(nwogCEArray), currentDayTimeClose)
                
            if showPriceLabels
                label.set_x(array.last(nwogHighLabel), currentDayTimeClose)
                label.set_x(array.last(nwogCELabel), currentDayTimeClose)
                label.set_x(array.last(nwogLowLabel), currentDayTimeClose)
            
            if eventHorizon
                line.set_x2(eventHorizonLine, currentDayTimeClose)

if showNDOG and timeframe.isintraday
    if helpers.isNewbar("D")// and dayOpeningGap.high != dayOpeningGap.low
        if (dayofweek != dayofweek.sunday and showNWOG) or not showNWOG
            string dayLabel = showDateLabel ? str.format_time(dayOpeningGap.start, dateFormat, syminfo.timezone) + " | " + ndogLabel : ndogLabel //showDayLabels ? getDayOfWeekLabel(dayofweek) + " | " + ndogLabel : ndogLabel
            float ndogCePrice = (dayOpeningGap.high + dayOpeningGap.low) / 2
            
            array.push(ndogArray, box.new(dayOpeningGap.start, dayOpeningGap.high, dayOpeningGap.end, dayOpeningGap.low, xloc = xloc.bar_time, bgcolor = ndogBg, border_width = 0, text = dayLabel, text_size = helpers.getTextSize(ndogLabelSize), text_halign = helpers.getBoxTextPosition(ndogLabelXPosition), text_valign = helpers.getBoxTextPosition(ndogLabelYPosition), text_color = ndogLabelColor))
        
            if showNdogCE
                array.push(ndogCEArray, line.new(dayOpeningGap.start, ndogCePrice, dayOpeningGap.end, ndogCePrice, xloc = xloc.bar_time, style = helpers.getLineStyle(ndogCEStyle), color = ndogCEColor))

            if showPriceLabels
                array.push(ndogHighLabel, label.new(dayOpeningGap.end, dayOpeningGap.high, str.tostring(dayOpeningGap.high, format.mintick), style = label.style_label_lower_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))
                array.push(ndogCELabel, label.new(dayOpeningGap.end, ndogCePrice, str.tostring(ndogCePrice, format.mintick), style = label.style_label_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))
                array.push(ndogLowLabel, label.new(dayOpeningGap.end, dayOpeningGap.low, str.tostring(dayOpeningGap.low, format.mintick), style = label.style_label_upper_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = priceLabelColor, size = helpers.getTextSize(priceLabelSize)))

            if array.size(ndogArray) > ndogsAmount
                box.delete(array.shift(ndogArray))

                if showNdogCE
                    line.delete(array.shift(ndogCEArray))
                
                if showPriceLabels
                    label.delete(array.shift(ndogHighLabel))
                    label.delete(array.shift(ndogCELabel))
                    label.delete(array.shift(ndogLowLabel))

        
    if extendAllNdogs and array.size(ndogArray) > 0
        for i = 0 to array.size(ndogArray) - 1
            box.set_right(array.get(ndogArray, i), dayOpeningGap.end)
            
            if (showNWOG and dayofweek == dayofweek.sunday and i <= array.size(ndogArray) - 1) or i < array.size(ndogArray) - 1
                box.set_bgcolor(array.get(ndogArray, i), previousNdogBg)

            if showNdogCE
                line.set_x2(array.get(ndogCEArray, i), dayOpeningGap.end)
            
            if showPriceLabels
                label.set_x(array.get(ndogHighLabel, i), dayOpeningGap.end)
                label.set_x(array.get(ndogCELabel, i), dayOpeningGap.end)
                label.set_x(array.get(ndogLowLabel, i), dayOpeningGap.end)
				
//----------------------------------------------------------opening gapes intrigation--------------------------------------------